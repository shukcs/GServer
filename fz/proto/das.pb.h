// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: das.proto

#ifndef PROTOBUF_das_2eproto__INCLUDED
#define PROTOBUF_das_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace das {
namespace proto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_das_2eproto();
void protobuf_AssignDesc_das_2eproto();
void protobuf_ShutdownFile_das_2eproto();

class PostHeartBeat;
class AckHeartBeat;
class SyncFZUserList;
class AckSyncFZUserList;
class UpdateFZUserList;
class AckUpdateFZUserList;
class RequestNewFZUser;
class AckNewFZUser;
class RequestFZUserIdentity;
class AckFZUserIdentity;
class PostChangeFZPswd;
class AckChangeFZPswd;
class FZUserMessage;
class AckFZUserMessage;
class RequestFriends;
class AckFriends;
class AddSWKey;
class AckAddSWKey;
class SWRegist;
class AckSWRegist;
class FZResult;
class PostFZResult;
class AckPostFZResult;
class RequestFZResults;
class AckFZResults;
class FZInfo;
class PostFZInfo;
class AckPostFZInfo;
class RequestFZInfo;
class AckFZInfo;
class PostGetFZPswd;
class AckGetFZPswd;

enum FZMsgType {
  DeleteFriend = 1,
  RequestFriend = 2,
  AgreeFriend = 3,
  RejectFriend = 4,
  Text = 5,
  Land = 6
};
bool FZMsgType_IsValid(int value);
const FZMsgType FZMsgType_MIN = DeleteFriend;
const FZMsgType FZMsgType_MAX = Land;
const int FZMsgType_ARRAYSIZE = FZMsgType_MAX + 1;

const ::google::protobuf::EnumDescriptor* FZMsgType_descriptor();
inline const ::std::string& FZMsgType_Name(FZMsgType value) {
  return ::google::protobuf::internal::NameOfEnum(
    FZMsgType_descriptor(), value);
}
inline bool FZMsgType_Parse(
    const ::std::string& name, FZMsgType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FZMsgType>(
    FZMsgType_descriptor(), name, value);
}
// ===================================================================

class PostHeartBeat : public ::google::protobuf::Message {
 public:
  PostHeartBeat();
  virtual ~PostHeartBeat();

  PostHeartBeat(const PostHeartBeat& from);

  inline PostHeartBeat& operator=(const PostHeartBeat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PostHeartBeat& default_instance();

  void Swap(PostHeartBeat* other);

  // implements Message ----------------------------------------------

  PostHeartBeat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PostHeartBeat& from);
  void MergeFrom(const PostHeartBeat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // optional string id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // @@protoc_insertion_point(class_scope:das.proto.PostHeartBeat)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::google::protobuf::uint32 seqno_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static PostHeartBeat* default_instance_;
};
// -------------------------------------------------------------------

class AckHeartBeat : public ::google::protobuf::Message {
 public:
  AckHeartBeat();
  virtual ~AckHeartBeat();

  AckHeartBeat(const AckHeartBeat& from);

  inline AckHeartBeat& operator=(const AckHeartBeat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckHeartBeat& default_instance();

  void Swap(AckHeartBeat* other);

  // implements Message ----------------------------------------------

  AckHeartBeat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckHeartBeat& from);
  void MergeFrom(const AckHeartBeat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:das.proto.AckHeartBeat)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 seqno_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static AckHeartBeat* default_instance_;
};
// -------------------------------------------------------------------

class SyncFZUserList : public ::google::protobuf::Message {
 public:
  SyncFZUserList();
  virtual ~SyncFZUserList();

  SyncFZUserList(const SyncFZUserList& from);

  inline SyncFZUserList& operator=(const SyncFZUserList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SyncFZUserList& default_instance();

  void Swap(SyncFZUserList* other);

  // implements Message ----------------------------------------------

  SyncFZUserList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SyncFZUserList& from);
  void MergeFrom(const SyncFZUserList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:das.proto.SyncFZUserList)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 seqno_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static SyncFZUserList* default_instance_;
};
// -------------------------------------------------------------------

class AckSyncFZUserList : public ::google::protobuf::Message {
 public:
  AckSyncFZUserList();
  virtual ~AckSyncFZUserList();

  AckSyncFZUserList(const AckSyncFZUserList& from);

  inline AckSyncFZUserList& operator=(const AckSyncFZUserList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckSyncFZUserList& default_instance();

  void Swap(AckSyncFZUserList* other);

  // implements Message ----------------------------------------------

  AckSyncFZUserList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckSyncFZUserList& from);
  void MergeFrom(const AckSyncFZUserList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // repeated string id = 3;
  inline int id_size() const;
  inline void clear_id();
  static const int kIdFieldNumber = 3;
  inline const ::std::string& id(int index) const;
  inline ::std::string* mutable_id(int index);
  inline void set_id(int index, const ::std::string& value);
  inline void set_id(int index, const char* value);
  inline void set_id(int index, const char* value, size_t size);
  inline ::std::string* add_id();
  inline void add_id(const ::std::string& value);
  inline void add_id(const char* value);
  inline void add_id(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& id() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_id();

  // @@protoc_insertion_point(class_scope:das.proto.AckSyncFZUserList)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 seqno_;
  ::google::protobuf::int32 result_;
  ::google::protobuf::RepeatedPtrField< ::std::string> id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static AckSyncFZUserList* default_instance_;
};
// -------------------------------------------------------------------

class UpdateFZUserList : public ::google::protobuf::Message {
 public:
  UpdateFZUserList();
  virtual ~UpdateFZUserList();

  UpdateFZUserList(const UpdateFZUserList& from);

  inline UpdateFZUserList& operator=(const UpdateFZUserList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateFZUserList& default_instance();

  void Swap(UpdateFZUserList* other);

  // implements Message ----------------------------------------------

  UpdateFZUserList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateFZUserList& from);
  void MergeFrom(const UpdateFZUserList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required uint32 operation = 2;
  inline bool has_operation() const;
  inline void clear_operation();
  static const int kOperationFieldNumber = 2;
  inline ::google::protobuf::uint32 operation() const;
  inline void set_operation(::google::protobuf::uint32 value);

  // repeated string id = 3;
  inline int id_size() const;
  inline void clear_id();
  static const int kIdFieldNumber = 3;
  inline const ::std::string& id(int index) const;
  inline ::std::string* mutable_id(int index);
  inline void set_id(int index, const ::std::string& value);
  inline void set_id(int index, const char* value);
  inline void set_id(int index, const char* value, size_t size);
  inline ::std::string* add_id();
  inline void add_id(const ::std::string& value);
  inline void add_id(const char* value);
  inline void add_id(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& id() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_id();

  // @@protoc_insertion_point(class_scope:das.proto.UpdateFZUserList)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_operation();
  inline void clear_has_operation();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 seqno_;
  ::google::protobuf::uint32 operation_;
  ::google::protobuf::RepeatedPtrField< ::std::string> id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static UpdateFZUserList* default_instance_;
};
// -------------------------------------------------------------------

class AckUpdateFZUserList : public ::google::protobuf::Message {
 public:
  AckUpdateFZUserList();
  virtual ~AckUpdateFZUserList();

  AckUpdateFZUserList(const AckUpdateFZUserList& from);

  inline AckUpdateFZUserList& operator=(const AckUpdateFZUserList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckUpdateFZUserList& default_instance();

  void Swap(AckUpdateFZUserList* other);

  // implements Message ----------------------------------------------

  AckUpdateFZUserList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckUpdateFZUserList& from);
  void MergeFrom(const AckUpdateFZUserList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:das.proto.AckUpdateFZUserList)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 seqno_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static AckUpdateFZUserList* default_instance_;
};
// -------------------------------------------------------------------

class RequestNewFZUser : public ::google::protobuf::Message {
 public:
  RequestNewFZUser();
  virtual ~RequestNewFZUser();

  RequestNewFZUser(const RequestNewFZUser& from);

  inline RequestNewFZUser& operator=(const RequestNewFZUser& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestNewFZUser& default_instance();

  void Swap(RequestNewFZUser* other);

  // implements Message ----------------------------------------------

  RequestNewFZUser* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestNewFZUser& from);
  void MergeFrom(const RequestNewFZUser& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required string user = 2;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 2;
  inline const ::std::string& user() const;
  inline void set_user(const ::std::string& value);
  inline void set_user(const char* value);
  inline void set_user(const char* value, size_t size);
  inline ::std::string* mutable_user();
  inline ::std::string* release_user();
  inline void set_allocated_user(::std::string* user);

  // optional string phone = 3;
  inline bool has_phone() const;
  inline void clear_phone();
  static const int kPhoneFieldNumber = 3;
  inline const ::std::string& phone() const;
  inline void set_phone(const ::std::string& value);
  inline void set_phone(const char* value);
  inline void set_phone(const char* value, size_t size);
  inline ::std::string* mutable_phone();
  inline ::std::string* release_phone();
  inline void set_allocated_phone(::std::string* phone);

  // optional string check = 4;
  inline bool has_check() const;
  inline void clear_check();
  static const int kCheckFieldNumber = 4;
  inline const ::std::string& check() const;
  inline void set_check(const ::std::string& value);
  inline void set_check(const char* value);
  inline void set_check(const char* value, size_t size);
  inline ::std::string* mutable_check();
  inline ::std::string* release_check();
  inline void set_allocated_check(::std::string* check);

  // optional string password = 5;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 5;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:das.proto.RequestNewFZUser)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_phone();
  inline void clear_has_phone();
  inline void set_has_check();
  inline void clear_has_check();
  inline void set_has_password();
  inline void clear_has_password();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* user_;
  ::std::string* phone_;
  ::std::string* check_;
  ::std::string* password_;
  ::google::protobuf::uint32 seqno_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static RequestNewFZUser* default_instance_;
};
// -------------------------------------------------------------------

class AckNewFZUser : public ::google::protobuf::Message {
 public:
  AckNewFZUser();
  virtual ~AckNewFZUser();

  AckNewFZUser(const AckNewFZUser& from);

  inline AckNewFZUser& operator=(const AckNewFZUser& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckNewFZUser& default_instance();

  void Swap(AckNewFZUser* other);

  // implements Message ----------------------------------------------

  AckNewFZUser* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckNewFZUser& from);
  void MergeFrom(const AckNewFZUser& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional string check = 3;
  inline bool has_check() const;
  inline void clear_check();
  static const int kCheckFieldNumber = 3;
  inline const ::std::string& check() const;
  inline void set_check(const ::std::string& value);
  inline void set_check(const char* value);
  inline void set_check(const char* value, size_t size);
  inline ::std::string* mutable_check();
  inline ::std::string* release_check();
  inline void set_allocated_check(::std::string* check);

  // @@protoc_insertion_point(class_scope:das.proto.AckNewFZUser)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_check();
  inline void clear_has_check();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 seqno_;
  ::google::protobuf::int32 result_;
  ::std::string* check_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static AckNewFZUser* default_instance_;
};
// -------------------------------------------------------------------

class RequestFZUserIdentity : public ::google::protobuf::Message {
 public:
  RequestFZUserIdentity();
  virtual ~RequestFZUserIdentity();

  RequestFZUserIdentity(const RequestFZUserIdentity& from);

  inline RequestFZUserIdentity& operator=(const RequestFZUserIdentity& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestFZUserIdentity& default_instance();

  void Swap(RequestFZUserIdentity* other);

  // implements Message ----------------------------------------------

  RequestFZUserIdentity* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestFZUserIdentity& from);
  void MergeFrom(const RequestFZUserIdentity& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required string user = 2;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 2;
  inline const ::std::string& user() const;
  inline void set_user(const ::std::string& value);
  inline void set_user(const char* value);
  inline void set_user(const char* value, size_t size);
  inline ::std::string* mutable_user();
  inline ::std::string* release_user();
  inline void set_allocated_user(::std::string* user);

  // required string pswd = 3;
  inline bool has_pswd() const;
  inline void clear_pswd();
  static const int kPswdFieldNumber = 3;
  inline const ::std::string& pswd() const;
  inline void set_pswd(const ::std::string& value);
  inline void set_pswd(const char* value);
  inline void set_pswd(const char* value, size_t size);
  inline ::std::string* mutable_pswd();
  inline ::std::string* release_pswd();
  inline void set_allocated_pswd(::std::string* pswd);

  // required string pcsn = 4;
  inline bool has_pcsn() const;
  inline void clear_pcsn();
  static const int kPcsnFieldNumber = 4;
  inline const ::std::string& pcsn() const;
  inline void set_pcsn(const ::std::string& value);
  inline void set_pcsn(const char* value);
  inline void set_pcsn(const char* value, size_t size);
  inline ::std::string* mutable_pcsn();
  inline ::std::string* release_pcsn();
  inline void set_allocated_pcsn(::std::string* pcsn);

  // @@protoc_insertion_point(class_scope:das.proto.RequestFZUserIdentity)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_pswd();
  inline void clear_has_pswd();
  inline void set_has_pcsn();
  inline void clear_has_pcsn();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* user_;
  ::std::string* pswd_;
  ::std::string* pcsn_;
  ::google::protobuf::uint32 seqno_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static RequestFZUserIdentity* default_instance_;
};
// -------------------------------------------------------------------

class AckFZUserIdentity : public ::google::protobuf::Message {
 public:
  AckFZUserIdentity();
  virtual ~AckFZUserIdentity();

  AckFZUserIdentity(const AckFZUserIdentity& from);

  inline AckFZUserIdentity& operator=(const AckFZUserIdentity& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckFZUserIdentity& default_instance();

  void Swap(AckFZUserIdentity* other);

  // implements Message ----------------------------------------------

  AckFZUserIdentity* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckFZUserIdentity& from);
  void MergeFrom(const AckFZUserIdentity& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // required int32 swver = 3;
  inline bool has_swver() const;
  inline void clear_swver();
  static const int kSwverFieldNumber = 3;
  inline ::google::protobuf::int32 swver() const;
  inline void set_swver(::google::protobuf::int32 value);

  // optional string extradata = 4;
  inline bool has_extradata() const;
  inline void clear_extradata();
  static const int kExtradataFieldNumber = 4;
  inline const ::std::string& extradata() const;
  inline void set_extradata(const ::std::string& value);
  inline void set_extradata(const char* value);
  inline void set_extradata(const char* value, size_t size);
  inline ::std::string* mutable_extradata();
  inline ::std::string* release_extradata();
  inline void set_allocated_extradata(::std::string* extradata);

  // @@protoc_insertion_point(class_scope:das.proto.AckFZUserIdentity)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_swver();
  inline void clear_has_swver();
  inline void set_has_extradata();
  inline void clear_has_extradata();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 seqno_;
  ::google::protobuf::int32 result_;
  ::std::string* extradata_;
  ::google::protobuf::int32 swver_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static AckFZUserIdentity* default_instance_;
};
// -------------------------------------------------------------------

class PostChangeFZPswd : public ::google::protobuf::Message {
 public:
  PostChangeFZPswd();
  virtual ~PostChangeFZPswd();

  PostChangeFZPswd(const PostChangeFZPswd& from);

  inline PostChangeFZPswd& operator=(const PostChangeFZPswd& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PostChangeFZPswd& default_instance();

  void Swap(PostChangeFZPswd* other);

  // implements Message ----------------------------------------------

  PostChangeFZPswd* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PostChangeFZPswd& from);
  void MergeFrom(const PostChangeFZPswd& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required string old = 2;
  inline bool has_old() const;
  inline void clear_old();
  static const int kOldFieldNumber = 2;
  inline const ::std::string& old() const;
  inline void set_old(const ::std::string& value);
  inline void set_old(const char* value);
  inline void set_old(const char* value, size_t size);
  inline ::std::string* mutable_old();
  inline ::std::string* release_old();
  inline void set_allocated_old(::std::string* old);

  // required string pswd = 3;
  inline bool has_pswd() const;
  inline void clear_pswd();
  static const int kPswdFieldNumber = 3;
  inline const ::std::string& pswd() const;
  inline void set_pswd(const ::std::string& value);
  inline void set_pswd(const char* value);
  inline void set_pswd(const char* value, size_t size);
  inline ::std::string* mutable_pswd();
  inline ::std::string* release_pswd();
  inline void set_allocated_pswd(::std::string* pswd);

  // @@protoc_insertion_point(class_scope:das.proto.PostChangeFZPswd)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_old();
  inline void clear_has_old();
  inline void set_has_pswd();
  inline void clear_has_pswd();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* old_;
  ::std::string* pswd_;
  ::google::protobuf::uint32 seqno_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static PostChangeFZPswd* default_instance_;
};
// -------------------------------------------------------------------

class AckChangeFZPswd : public ::google::protobuf::Message {
 public:
  AckChangeFZPswd();
  virtual ~AckChangeFZPswd();

  AckChangeFZPswd(const AckChangeFZPswd& from);

  inline AckChangeFZPswd& operator=(const AckChangeFZPswd& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckChangeFZPswd& default_instance();

  void Swap(AckChangeFZPswd* other);

  // implements Message ----------------------------------------------

  AckChangeFZPswd* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckChangeFZPswd& from);
  void MergeFrom(const AckChangeFZPswd& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:das.proto.AckChangeFZPswd)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 seqno_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static AckChangeFZPswd* default_instance_;
};
// -------------------------------------------------------------------

class FZUserMessage : public ::google::protobuf::Message {
 public:
  FZUserMessage();
  virtual ~FZUserMessage();

  FZUserMessage(const FZUserMessage& from);

  inline FZUserMessage& operator=(const FZUserMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FZUserMessage& default_instance();

  void Swap(FZUserMessage* other);

  // implements Message ----------------------------------------------

  FZUserMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FZUserMessage& from);
  void MergeFrom(const FZUserMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required .das.proto.FZMsgType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::das::proto::FZMsgType type() const;
  inline void set_type(::das::proto::FZMsgType value);

  // required string from = 3;
  inline bool has_from() const;
  inline void clear_from();
  static const int kFromFieldNumber = 3;
  inline const ::std::string& from() const;
  inline void set_from(const ::std::string& value);
  inline void set_from(const char* value);
  inline void set_from(const char* value, size_t size);
  inline ::std::string* mutable_from();
  inline ::std::string* release_from();
  inline void set_allocated_from(::std::string* from);

  // required string to = 4;
  inline bool has_to() const;
  inline void clear_to();
  static const int kToFieldNumber = 4;
  inline const ::std::string& to() const;
  inline void set_to(const ::std::string& value);
  inline void set_to(const char* value);
  inline void set_to(const char* value, size_t size);
  inline ::std::string* mutable_to();
  inline ::std::string* release_to();
  inline void set_allocated_to(::std::string* to);

  // optional bytes content = 5;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 5;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const void* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // @@protoc_insertion_point(class_scope:das.proto.FZUserMessage)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_from();
  inline void clear_has_from();
  inline void set_has_to();
  inline void clear_has_to();
  inline void set_has_content();
  inline void clear_has_content();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 seqno_;
  int type_;
  ::std::string* from_;
  ::std::string* to_;
  ::std::string* content_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static FZUserMessage* default_instance_;
};
// -------------------------------------------------------------------

class AckFZUserMessage : public ::google::protobuf::Message {
 public:
  AckFZUserMessage();
  virtual ~AckFZUserMessage();

  AckFZUserMessage(const AckFZUserMessage& from);

  inline AckFZUserMessage& operator=(const AckFZUserMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckFZUserMessage& default_instance();

  void Swap(AckFZUserMessage* other);

  // implements Message ----------------------------------------------

  AckFZUserMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckFZUserMessage& from);
  void MergeFrom(const AckFZUserMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required uint32 res = 2;
  inline bool has_res() const;
  inline void clear_res();
  static const int kResFieldNumber = 2;
  inline ::google::protobuf::uint32 res() const;
  inline void set_res(::google::protobuf::uint32 value);

  // required string user = 3;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 3;
  inline const ::std::string& user() const;
  inline void set_user(const ::std::string& value);
  inline void set_user(const char* value);
  inline void set_user(const char* value, size_t size);
  inline ::std::string* mutable_user();
  inline ::std::string* release_user();
  inline void set_allocated_user(::std::string* user);

  // @@protoc_insertion_point(class_scope:das.proto.AckFZUserMessage)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_res();
  inline void clear_has_res();
  inline void set_has_user();
  inline void clear_has_user();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 seqno_;
  ::google::protobuf::uint32 res_;
  ::std::string* user_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static AckFZUserMessage* default_instance_;
};
// -------------------------------------------------------------------

class RequestFriends : public ::google::protobuf::Message {
 public:
  RequestFriends();
  virtual ~RequestFriends();

  RequestFriends(const RequestFriends& from);

  inline RequestFriends& operator=(const RequestFriends& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestFriends& default_instance();

  void Swap(RequestFriends* other);

  // implements Message ----------------------------------------------

  RequestFriends* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestFriends& from);
  void MergeFrom(const RequestFriends& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:das.proto.RequestFriends)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 seqno_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static RequestFriends* default_instance_;
};
// -------------------------------------------------------------------

class AckFriends : public ::google::protobuf::Message {
 public:
  AckFriends();
  virtual ~AckFriends();

  AckFriends(const AckFriends& from);

  inline AckFriends& operator=(const AckFriends& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckFriends& default_instance();

  void Swap(AckFriends* other);

  // implements Message ----------------------------------------------

  AckFriends* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckFriends& from);
  void MergeFrom(const AckFriends& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // repeated string friends = 2;
  inline int friends_size() const;
  inline void clear_friends();
  static const int kFriendsFieldNumber = 2;
  inline const ::std::string& friends(int index) const;
  inline ::std::string* mutable_friends(int index);
  inline void set_friends(int index, const ::std::string& value);
  inline void set_friends(int index, const char* value);
  inline void set_friends(int index, const char* value, size_t size);
  inline ::std::string* add_friends();
  inline void add_friends(const ::std::string& value);
  inline void add_friends(const char* value);
  inline void add_friends(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& friends() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_friends();

  // @@protoc_insertion_point(class_scope:das.proto.AckFriends)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> friends_;
  ::google::protobuf::uint32 seqno_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static AckFriends* default_instance_;
};
// -------------------------------------------------------------------

class AddSWKey : public ::google::protobuf::Message {
 public:
  AddSWKey();
  virtual ~AddSWKey();

  AddSWKey(const AddSWKey& from);

  inline AddSWKey& operator=(const AddSWKey& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AddSWKey& default_instance();

  void Swap(AddSWKey* other);

  // implements Message ----------------------------------------------

  AddSWKey* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AddSWKey& from);
  void MergeFrom(const AddSWKey& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required string swkey = 2;
  inline bool has_swkey() const;
  inline void clear_swkey();
  static const int kSwkeyFieldNumber = 2;
  inline const ::std::string& swkey() const;
  inline void set_swkey(const ::std::string& value);
  inline void set_swkey(const char* value);
  inline void set_swkey(const char* value, size_t size);
  inline ::std::string* mutable_swkey();
  inline ::std::string* release_swkey();
  inline void set_allocated_swkey(::std::string* swkey);

  // optional uint32 ver = 3;
  inline bool has_ver() const;
  inline void clear_ver();
  static const int kVerFieldNumber = 3;
  inline ::google::protobuf::uint32 ver() const;
  inline void set_ver(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:das.proto.AddSWKey)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_swkey();
  inline void clear_has_swkey();
  inline void set_has_ver();
  inline void clear_has_ver();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* swkey_;
  ::google::protobuf::uint32 seqno_;
  ::google::protobuf::uint32 ver_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static AddSWKey* default_instance_;
};
// -------------------------------------------------------------------

class AckAddSWKey : public ::google::protobuf::Message {
 public:
  AckAddSWKey();
  virtual ~AckAddSWKey();

  AckAddSWKey(const AckAddSWKey& from);

  inline AckAddSWKey& operator=(const AckAddSWKey& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckAddSWKey& default_instance();

  void Swap(AckAddSWKey* other);

  // implements Message ----------------------------------------------

  AckAddSWKey* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckAddSWKey& from);
  void MergeFrom(const AckAddSWKey& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:das.proto.AckAddSWKey)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 seqno_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static AckAddSWKey* default_instance_;
};
// -------------------------------------------------------------------

class SWRegist : public ::google::protobuf::Message {
 public:
  SWRegist();
  virtual ~SWRegist();

  SWRegist(const SWRegist& from);

  inline SWRegist& operator=(const SWRegist& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SWRegist& default_instance();

  void Swap(SWRegist* other);

  // implements Message ----------------------------------------------

  SWRegist* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SWRegist& from);
  void MergeFrom(const SWRegist& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required string pcsn = 2;
  inline bool has_pcsn() const;
  inline void clear_pcsn();
  static const int kPcsnFieldNumber = 2;
  inline const ::std::string& pcsn() const;
  inline void set_pcsn(const ::std::string& value);
  inline void set_pcsn(const char* value);
  inline void set_pcsn(const char* value, size_t size);
  inline ::std::string* mutable_pcsn();
  inline ::std::string* release_pcsn();
  inline void set_allocated_pcsn(::std::string* pcsn);

  // required string swkey = 3;
  inline bool has_swkey() const;
  inline void clear_swkey();
  static const int kSwkeyFieldNumber = 3;
  inline const ::std::string& swkey() const;
  inline void set_swkey(const ::std::string& value);
  inline void set_swkey(const char* value);
  inline void set_swkey(const char* value, size_t size);
  inline ::std::string* mutable_swkey();
  inline ::std::string* release_swkey();
  inline void set_allocated_swkey(::std::string* swkey);

  // optional uint32 ver = 4;
  inline bool has_ver() const;
  inline void clear_ver();
  static const int kVerFieldNumber = 4;
  inline ::google::protobuf::uint32 ver() const;
  inline void set_ver(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:das.proto.SWRegist)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_pcsn();
  inline void clear_has_pcsn();
  inline void set_has_swkey();
  inline void clear_has_swkey();
  inline void set_has_ver();
  inline void clear_has_ver();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* pcsn_;
  ::google::protobuf::uint32 seqno_;
  ::google::protobuf::uint32 ver_;
  ::std::string* swkey_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static SWRegist* default_instance_;
};
// -------------------------------------------------------------------

class AckSWRegist : public ::google::protobuf::Message {
 public:
  AckSWRegist();
  virtual ~AckSWRegist();

  AckSWRegist(const AckSWRegist& from);

  inline AckSWRegist& operator=(const AckSWRegist& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckSWRegist& default_instance();

  void Swap(AckSWRegist* other);

  // implements Message ----------------------------------------------

  AckSWRegist* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckSWRegist& from);
  void MergeFrom(const AckSWRegist& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:das.proto.AckSWRegist)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 seqno_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static AckSWRegist* default_instance_;
};
// -------------------------------------------------------------------

class FZResult : public ::google::protobuf::Message {
 public:
  FZResult();
  virtual ~FZResult();

  FZResult(const FZResult& from);

  inline FZResult& operator=(const FZResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FZResult& default_instance();

  void Swap(FZResult* other);

  // implements Message ----------------------------------------------

  FZResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FZResult& from);
  void MergeFrom(const FZResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int64 id() const;
  inline void set_id(::google::protobuf::int64 value);

  // optional int64 begTm = 2;
  inline bool has_begtm() const;
  inline void clear_begtm();
  static const int kBegTmFieldNumber = 2;
  inline ::google::protobuf::int64 begtm() const;
  inline void set_begtm(::google::protobuf::int64 value);

  // required int32 usedTm = 3;
  inline bool has_usedtm() const;
  inline void clear_usedtm();
  static const int kUsedTmFieldNumber = 3;
  inline ::google::protobuf::int32 usedtm() const;
  inline void set_usedtm(::google::protobuf::int32 value);

  // required int32 type = 4;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 4;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // required int32 rslt = 5;
  inline bool has_rslt() const;
  inline void clear_rslt();
  static const int kRsltFieldNumber = 5;
  inline ::google::protobuf::int32 rslt() const;
  inline void set_rslt(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:das.proto.FZResult)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_begtm();
  inline void clear_has_begtm();
  inline void set_has_usedtm();
  inline void clear_has_usedtm();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_rslt();
  inline void clear_has_rslt();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 id_;
  ::google::protobuf::int64 begtm_;
  ::google::protobuf::int32 usedtm_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 rslt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static FZResult* default_instance_;
};
// -------------------------------------------------------------------

class PostFZResult : public ::google::protobuf::Message {
 public:
  PostFZResult();
  virtual ~PostFZResult();

  PostFZResult(const PostFZResult& from);

  inline PostFZResult& operator=(const PostFZResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PostFZResult& default_instance();

  void Swap(PostFZResult* other);

  // implements Message ----------------------------------------------

  PostFZResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PostFZResult& from);
  void MergeFrom(const PostFZResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required .das.proto.FZResult rslt = 2;
  inline bool has_rslt() const;
  inline void clear_rslt();
  static const int kRsltFieldNumber = 2;
  inline const ::das::proto::FZResult& rslt() const;
  inline ::das::proto::FZResult* mutable_rslt();
  inline ::das::proto::FZResult* release_rslt();
  inline void set_allocated_rslt(::das::proto::FZResult* rslt);

  // @@protoc_insertion_point(class_scope:das.proto.PostFZResult)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_rslt();
  inline void clear_has_rslt();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::das::proto::FZResult* rslt_;
  ::google::protobuf::uint32 seqno_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static PostFZResult* default_instance_;
};
// -------------------------------------------------------------------

class AckPostFZResult : public ::google::protobuf::Message {
 public:
  AckPostFZResult();
  virtual ~AckPostFZResult();

  AckPostFZResult(const AckPostFZResult& from);

  inline AckPostFZResult& operator=(const AckPostFZResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckPostFZResult& default_instance();

  void Swap(AckPostFZResult* other);

  // implements Message ----------------------------------------------

  AckPostFZResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckPostFZResult& from);
  void MergeFrom(const AckPostFZResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required int64 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::int64 id() const;
  inline void set_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:das.proto.AckPostFZResult)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 id_;
  ::google::protobuf::uint32 seqno_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static AckPostFZResult* default_instance_;
};
// -------------------------------------------------------------------

class RequestFZResults : public ::google::protobuf::Message {
 public:
  RequestFZResults();
  virtual ~RequestFZResults();

  RequestFZResults(const RequestFZResults& from);

  inline RequestFZResults& operator=(const RequestFZResults& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestFZResults& default_instance();

  void Swap(RequestFZResults* other);

  // implements Message ----------------------------------------------

  RequestFZResults* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestFZResults& from);
  void MergeFrom(const RequestFZResults& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // optional int64 tmbeg = 2;
  inline bool has_tmbeg() const;
  inline void clear_tmbeg();
  static const int kTmbegFieldNumber = 2;
  inline ::google::protobuf::int64 tmbeg() const;
  inline void set_tmbeg(::google::protobuf::int64 value);

  // optional int64 tmend = 3;
  inline bool has_tmend() const;
  inline void clear_tmend();
  static const int kTmendFieldNumber = 3;
  inline ::google::protobuf::int64 tmend() const;
  inline void set_tmend(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:das.proto.RequestFZResults)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_tmbeg();
  inline void clear_has_tmbeg();
  inline void set_has_tmend();
  inline void clear_has_tmend();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 tmbeg_;
  ::google::protobuf::int64 tmend_;
  ::google::protobuf::uint32 seqno_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static RequestFZResults* default_instance_;
};
// -------------------------------------------------------------------

class AckFZResults : public ::google::protobuf::Message {
 public:
  AckFZResults();
  virtual ~AckFZResults();

  AckFZResults(const AckFZResults& from);

  inline AckFZResults& operator=(const AckFZResults& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckFZResults& default_instance();

  void Swap(AckFZResults* other);

  // implements Message ----------------------------------------------

  AckFZResults* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckFZResults& from);
  void MergeFrom(const AckFZResults& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // repeated .das.proto.FZResult rslt = 2;
  inline int rslt_size() const;
  inline void clear_rslt();
  static const int kRsltFieldNumber = 2;
  inline const ::das::proto::FZResult& rslt(int index) const;
  inline ::das::proto::FZResult* mutable_rslt(int index);
  inline ::das::proto::FZResult* add_rslt();
  inline const ::google::protobuf::RepeatedPtrField< ::das::proto::FZResult >&
      rslt() const;
  inline ::google::protobuf::RepeatedPtrField< ::das::proto::FZResult >*
      mutable_rslt();

  // @@protoc_insertion_point(class_scope:das.proto.AckFZResults)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::das::proto::FZResult > rslt_;
  ::google::protobuf::uint32 seqno_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static AckFZResults* default_instance_;
};
// -------------------------------------------------------------------

class FZInfo : public ::google::protobuf::Message {
 public:
  FZInfo();
  virtual ~FZInfo();

  FZInfo(const FZInfo& from);

  inline FZInfo& operator=(const FZInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FZInfo& default_instance();

  void Swap(FZInfo* other);

  // implements Message ----------------------------------------------

  FZInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FZInfo& from);
  void MergeFrom(const FZInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string grade = 2;
  inline bool has_grade() const;
  inline void clear_grade();
  static const int kGradeFieldNumber = 2;
  inline const ::std::string& grade() const;
  inline void set_grade(const ::std::string& value);
  inline void set_grade(const char* value);
  inline void set_grade(const char* value, size_t size);
  inline ::std::string* mutable_grade();
  inline ::std::string* release_grade();
  inline void set_allocated_grade(::std::string* grade);

  // optional string majr = 3;
  inline bool has_majr() const;
  inline void clear_majr();
  static const int kMajrFieldNumber = 3;
  inline const ::std::string& majr() const;
  inline void set_majr(const ::std::string& value);
  inline void set_majr(const char* value);
  inline void set_majr(const char* value, size_t size);
  inline ::std::string* mutable_majr();
  inline ::std::string* release_majr();
  inline void set_allocated_majr(::std::string* majr);

  // optional string id = 4;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 4;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional string school = 5;
  inline bool has_school() const;
  inline void clear_school();
  static const int kSchoolFieldNumber = 5;
  inline const ::std::string& school() const;
  inline void set_school(const ::std::string& value);
  inline void set_school(const char* value);
  inline void set_school(const char* value, size_t size);
  inline ::std::string* mutable_school();
  inline ::std::string* release_school();
  inline void set_allocated_school(::std::string* school);

  // optional string births = 6;
  inline bool has_births() const;
  inline void clear_births();
  static const int kBirthsFieldNumber = 6;
  inline const ::std::string& births() const;
  inline void set_births(const ::std::string& value);
  inline void set_births(const char* value);
  inline void set_births(const char* value, size_t size);
  inline ::std::string* mutable_births();
  inline ::std::string* release_births();
  inline void set_allocated_births(::std::string* births);

  // required string email = 7;
  inline bool has_email() const;
  inline void clear_email();
  static const int kEmailFieldNumber = 7;
  inline const ::std::string& email() const;
  inline void set_email(const ::std::string& value);
  inline void set_email(const char* value);
  inline void set_email(const char* value, size_t size);
  inline ::std::string* mutable_email();
  inline ::std::string* release_email();
  inline void set_allocated_email(::std::string* email);

  // @@protoc_insertion_point(class_scope:das.proto.FZInfo)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_grade();
  inline void clear_has_grade();
  inline void set_has_majr();
  inline void clear_has_majr();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_school();
  inline void clear_has_school();
  inline void set_has_births();
  inline void clear_has_births();
  inline void set_has_email();
  inline void clear_has_email();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* grade_;
  ::std::string* majr_;
  ::std::string* id_;
  ::std::string* school_;
  ::std::string* births_;
  ::std::string* email_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static FZInfo* default_instance_;
};
// -------------------------------------------------------------------

class PostFZInfo : public ::google::protobuf::Message {
 public:
  PostFZInfo();
  virtual ~PostFZInfo();

  PostFZInfo(const PostFZInfo& from);

  inline PostFZInfo& operator=(const PostFZInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PostFZInfo& default_instance();

  void Swap(PostFZInfo* other);

  // implements Message ----------------------------------------------

  PostFZInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PostFZInfo& from);
  void MergeFrom(const PostFZInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required .das.proto.FZInfo info = 2;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 2;
  inline const ::das::proto::FZInfo& info() const;
  inline ::das::proto::FZInfo* mutable_info();
  inline ::das::proto::FZInfo* release_info();
  inline void set_allocated_info(::das::proto::FZInfo* info);

  // @@protoc_insertion_point(class_scope:das.proto.PostFZInfo)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_info();
  inline void clear_has_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::das::proto::FZInfo* info_;
  ::google::protobuf::uint32 seqno_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static PostFZInfo* default_instance_;
};
// -------------------------------------------------------------------

class AckPostFZInfo : public ::google::protobuf::Message {
 public:
  AckPostFZInfo();
  virtual ~AckPostFZInfo();

  AckPostFZInfo(const AckPostFZInfo& from);

  inline AckPostFZInfo& operator=(const AckPostFZInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckPostFZInfo& default_instance();

  void Swap(AckPostFZInfo* other);

  // implements Message ----------------------------------------------

  AckPostFZInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckPostFZInfo& from);
  void MergeFrom(const AckPostFZInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required int32 rslt = 2;
  inline bool has_rslt() const;
  inline void clear_rslt();
  static const int kRsltFieldNumber = 2;
  inline ::google::protobuf::int32 rslt() const;
  inline void set_rslt(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:das.proto.AckPostFZInfo)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_rslt();
  inline void clear_has_rslt();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 seqno_;
  ::google::protobuf::int32 rslt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static AckPostFZInfo* default_instance_;
};
// -------------------------------------------------------------------

class RequestFZInfo : public ::google::protobuf::Message {
 public:
  RequestFZInfo();
  virtual ~RequestFZInfo();

  RequestFZInfo(const RequestFZInfo& from);

  inline RequestFZInfo& operator=(const RequestFZInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestFZInfo& default_instance();

  void Swap(RequestFZInfo* other);

  // implements Message ----------------------------------------------

  RequestFZInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestFZInfo& from);
  void MergeFrom(const RequestFZInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:das.proto.RequestFZInfo)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 seqno_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static RequestFZInfo* default_instance_;
};
// -------------------------------------------------------------------

class AckFZInfo : public ::google::protobuf::Message {
 public:
  AckFZInfo();
  virtual ~AckFZInfo();

  AckFZInfo(const AckFZInfo& from);

  inline AckFZInfo& operator=(const AckFZInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckFZInfo& default_instance();

  void Swap(AckFZInfo* other);

  // implements Message ----------------------------------------------

  AckFZInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckFZInfo& from);
  void MergeFrom(const AckFZInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // optional .das.proto.FZInfo info = 2;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 2;
  inline const ::das::proto::FZInfo& info() const;
  inline ::das::proto::FZInfo* mutable_info();
  inline ::das::proto::FZInfo* release_info();
  inline void set_allocated_info(::das::proto::FZInfo* info);

  // @@protoc_insertion_point(class_scope:das.proto.AckFZInfo)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_info();
  inline void clear_has_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::das::proto::FZInfo* info_;
  ::google::protobuf::uint32 seqno_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static AckFZInfo* default_instance_;
};
// -------------------------------------------------------------------

class PostGetFZPswd : public ::google::protobuf::Message {
 public:
  PostGetFZPswd();
  virtual ~PostGetFZPswd();

  PostGetFZPswd(const PostGetFZPswd& from);

  inline PostGetFZPswd& operator=(const PostGetFZPswd& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PostGetFZPswd& default_instance();

  void Swap(PostGetFZPswd* other);

  // implements Message ----------------------------------------------

  PostGetFZPswd* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PostGetFZPswd& from);
  void MergeFrom(const PostGetFZPswd& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required string email = 2;
  inline bool has_email() const;
  inline void clear_email();
  static const int kEmailFieldNumber = 2;
  inline const ::std::string& email() const;
  inline void set_email(const ::std::string& value);
  inline void set_email(const char* value);
  inline void set_email(const char* value, size_t size);
  inline ::std::string* mutable_email();
  inline ::std::string* release_email();
  inline void set_allocated_email(::std::string* email);

  // required string user = 3;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 3;
  inline const ::std::string& user() const;
  inline void set_user(const ::std::string& value);
  inline void set_user(const char* value);
  inline void set_user(const char* value, size_t size);
  inline ::std::string* mutable_user();
  inline ::std::string* release_user();
  inline void set_allocated_user(::std::string* user);

  // @@protoc_insertion_point(class_scope:das.proto.PostGetFZPswd)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_email();
  inline void clear_has_email();
  inline void set_has_user();
  inline void clear_has_user();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* email_;
  ::std::string* user_;
  ::google::protobuf::uint32 seqno_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static PostGetFZPswd* default_instance_;
};
// -------------------------------------------------------------------

class AckGetFZPswd : public ::google::protobuf::Message {
 public:
  AckGetFZPswd();
  virtual ~AckGetFZPswd();

  AckGetFZPswd(const AckGetFZPswd& from);

  inline AckGetFZPswd& operator=(const AckGetFZPswd& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckGetFZPswd& default_instance();

  void Swap(AckGetFZPswd* other);

  // implements Message ----------------------------------------------

  AckGetFZPswd* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckGetFZPswd& from);
  void MergeFrom(const AckGetFZPswd& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required int32 rslt = 2;
  inline bool has_rslt() const;
  inline void clear_rslt();
  static const int kRsltFieldNumber = 2;
  inline ::google::protobuf::int32 rslt() const;
  inline void set_rslt(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:das.proto.AckGetFZPswd)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_rslt();
  inline void clear_has_rslt();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 seqno_;
  ::google::protobuf::int32 rslt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static AckGetFZPswd* default_instance_;
};
// ===================================================================


// ===================================================================

// PostHeartBeat

// required uint32 seqno = 1;
inline bool PostHeartBeat::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PostHeartBeat::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PostHeartBeat::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PostHeartBeat::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 PostHeartBeat::seqno() const {
  return seqno_;
}
inline void PostHeartBeat::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// optional string id = 2;
inline bool PostHeartBeat::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PostHeartBeat::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PostHeartBeat::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PostHeartBeat::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& PostHeartBeat::id() const {
  return *id_;
}
inline void PostHeartBeat::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void PostHeartBeat::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void PostHeartBeat::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PostHeartBeat::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* PostHeartBeat::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PostHeartBeat::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AckHeartBeat

// required uint32 seqno = 1;
inline bool AckHeartBeat::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckHeartBeat::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckHeartBeat::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckHeartBeat::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 AckHeartBeat::seqno() const {
  return seqno_;
}
inline void AckHeartBeat::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// -------------------------------------------------------------------

// SyncFZUserList

// required uint32 seqno = 1;
inline bool SyncFZUserList::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SyncFZUserList::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SyncFZUserList::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SyncFZUserList::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 SyncFZUserList::seqno() const {
  return seqno_;
}
inline void SyncFZUserList::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// -------------------------------------------------------------------

// AckSyncFZUserList

// required uint32 seqno = 1;
inline bool AckSyncFZUserList::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckSyncFZUserList::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckSyncFZUserList::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckSyncFZUserList::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 AckSyncFZUserList::seqno() const {
  return seqno_;
}
inline void AckSyncFZUserList::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required int32 result = 2;
inline bool AckSyncFZUserList::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckSyncFZUserList::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckSyncFZUserList::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckSyncFZUserList::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 AckSyncFZUserList::result() const {
  return result_;
}
inline void AckSyncFZUserList::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// repeated string id = 3;
inline int AckSyncFZUserList::id_size() const {
  return id_.size();
}
inline void AckSyncFZUserList::clear_id() {
  id_.Clear();
}
inline const ::std::string& AckSyncFZUserList::id(int index) const {
  return id_.Get(index);
}
inline ::std::string* AckSyncFZUserList::mutable_id(int index) {
  return id_.Mutable(index);
}
inline void AckSyncFZUserList::set_id(int index, const ::std::string& value) {
  id_.Mutable(index)->assign(value);
}
inline void AckSyncFZUserList::set_id(int index, const char* value) {
  id_.Mutable(index)->assign(value);
}
inline void AckSyncFZUserList::set_id(int index, const char* value, size_t size) {
  id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckSyncFZUserList::add_id() {
  return id_.Add();
}
inline void AckSyncFZUserList::add_id(const ::std::string& value) {
  id_.Add()->assign(value);
}
inline void AckSyncFZUserList::add_id(const char* value) {
  id_.Add()->assign(value);
}
inline void AckSyncFZUserList::add_id(const char* value, size_t size) {
  id_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
AckSyncFZUserList::id() const {
  return id_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
AckSyncFZUserList::mutable_id() {
  return &id_;
}

// -------------------------------------------------------------------

// UpdateFZUserList

// required uint32 seqno = 1;
inline bool UpdateFZUserList::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateFZUserList::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateFZUserList::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateFZUserList::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 UpdateFZUserList::seqno() const {
  return seqno_;
}
inline void UpdateFZUserList::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required uint32 operation = 2;
inline bool UpdateFZUserList::has_operation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdateFZUserList::set_has_operation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdateFZUserList::clear_has_operation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdateFZUserList::clear_operation() {
  operation_ = 0u;
  clear_has_operation();
}
inline ::google::protobuf::uint32 UpdateFZUserList::operation() const {
  return operation_;
}
inline void UpdateFZUserList::set_operation(::google::protobuf::uint32 value) {
  set_has_operation();
  operation_ = value;
}

// repeated string id = 3;
inline int UpdateFZUserList::id_size() const {
  return id_.size();
}
inline void UpdateFZUserList::clear_id() {
  id_.Clear();
}
inline const ::std::string& UpdateFZUserList::id(int index) const {
  return id_.Get(index);
}
inline ::std::string* UpdateFZUserList::mutable_id(int index) {
  return id_.Mutable(index);
}
inline void UpdateFZUserList::set_id(int index, const ::std::string& value) {
  id_.Mutable(index)->assign(value);
}
inline void UpdateFZUserList::set_id(int index, const char* value) {
  id_.Mutable(index)->assign(value);
}
inline void UpdateFZUserList::set_id(int index, const char* value, size_t size) {
  id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateFZUserList::add_id() {
  return id_.Add();
}
inline void UpdateFZUserList::add_id(const ::std::string& value) {
  id_.Add()->assign(value);
}
inline void UpdateFZUserList::add_id(const char* value) {
  id_.Add()->assign(value);
}
inline void UpdateFZUserList::add_id(const char* value, size_t size) {
  id_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
UpdateFZUserList::id() const {
  return id_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
UpdateFZUserList::mutable_id() {
  return &id_;
}

// -------------------------------------------------------------------

// AckUpdateFZUserList

// required uint32 seqno = 1;
inline bool AckUpdateFZUserList::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckUpdateFZUserList::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckUpdateFZUserList::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckUpdateFZUserList::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 AckUpdateFZUserList::seqno() const {
  return seqno_;
}
inline void AckUpdateFZUserList::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required int32 result = 2;
inline bool AckUpdateFZUserList::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckUpdateFZUserList::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckUpdateFZUserList::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckUpdateFZUserList::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 AckUpdateFZUserList::result() const {
  return result_;
}
inline void AckUpdateFZUserList::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// RequestNewFZUser

// required uint32 seqno = 1;
inline bool RequestNewFZUser::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestNewFZUser::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestNewFZUser::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestNewFZUser::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 RequestNewFZUser::seqno() const {
  return seqno_;
}
inline void RequestNewFZUser::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required string user = 2;
inline bool RequestNewFZUser::has_user() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestNewFZUser::set_has_user() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestNewFZUser::clear_has_user() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestNewFZUser::clear_user() {
  if (user_ != &::google::protobuf::internal::kEmptyString) {
    user_->clear();
  }
  clear_has_user();
}
inline const ::std::string& RequestNewFZUser::user() const {
  return *user_;
}
inline void RequestNewFZUser::set_user(const ::std::string& value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void RequestNewFZUser::set_user(const char* value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void RequestNewFZUser::set_user(const char* value, size_t size) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestNewFZUser::mutable_user() {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  return user_;
}
inline ::std::string* RequestNewFZUser::release_user() {
  clear_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_;
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestNewFZUser::set_allocated_user(::std::string* user) {
  if (user_ != &::google::protobuf::internal::kEmptyString) {
    delete user_;
  }
  if (user) {
    set_has_user();
    user_ = user;
  } else {
    clear_has_user();
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string phone = 3;
inline bool RequestNewFZUser::has_phone() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestNewFZUser::set_has_phone() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestNewFZUser::clear_has_phone() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestNewFZUser::clear_phone() {
  if (phone_ != &::google::protobuf::internal::kEmptyString) {
    phone_->clear();
  }
  clear_has_phone();
}
inline const ::std::string& RequestNewFZUser::phone() const {
  return *phone_;
}
inline void RequestNewFZUser::set_phone(const ::std::string& value) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(value);
}
inline void RequestNewFZUser::set_phone(const char* value) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(value);
}
inline void RequestNewFZUser::set_phone(const char* value, size_t size) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestNewFZUser::mutable_phone() {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  return phone_;
}
inline ::std::string* RequestNewFZUser::release_phone() {
  clear_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = phone_;
    phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestNewFZUser::set_allocated_phone(::std::string* phone) {
  if (phone_ != &::google::protobuf::internal::kEmptyString) {
    delete phone_;
  }
  if (phone) {
    set_has_phone();
    phone_ = phone;
  } else {
    clear_has_phone();
    phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string check = 4;
inline bool RequestNewFZUser::has_check() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestNewFZUser::set_has_check() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestNewFZUser::clear_has_check() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestNewFZUser::clear_check() {
  if (check_ != &::google::protobuf::internal::kEmptyString) {
    check_->clear();
  }
  clear_has_check();
}
inline const ::std::string& RequestNewFZUser::check() const {
  return *check_;
}
inline void RequestNewFZUser::set_check(const ::std::string& value) {
  set_has_check();
  if (check_ == &::google::protobuf::internal::kEmptyString) {
    check_ = new ::std::string;
  }
  check_->assign(value);
}
inline void RequestNewFZUser::set_check(const char* value) {
  set_has_check();
  if (check_ == &::google::protobuf::internal::kEmptyString) {
    check_ = new ::std::string;
  }
  check_->assign(value);
}
inline void RequestNewFZUser::set_check(const char* value, size_t size) {
  set_has_check();
  if (check_ == &::google::protobuf::internal::kEmptyString) {
    check_ = new ::std::string;
  }
  check_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestNewFZUser::mutable_check() {
  set_has_check();
  if (check_ == &::google::protobuf::internal::kEmptyString) {
    check_ = new ::std::string;
  }
  return check_;
}
inline ::std::string* RequestNewFZUser::release_check() {
  clear_has_check();
  if (check_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = check_;
    check_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestNewFZUser::set_allocated_check(::std::string* check) {
  if (check_ != &::google::protobuf::internal::kEmptyString) {
    delete check_;
  }
  if (check) {
    set_has_check();
    check_ = check;
  } else {
    clear_has_check();
    check_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string password = 5;
inline bool RequestNewFZUser::has_password() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RequestNewFZUser::set_has_password() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RequestNewFZUser::clear_has_password() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RequestNewFZUser::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& RequestNewFZUser::password() const {
  return *password_;
}
inline void RequestNewFZUser::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void RequestNewFZUser::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void RequestNewFZUser::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestNewFZUser::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* RequestNewFZUser::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestNewFZUser::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AckNewFZUser

// required uint32 seqno = 1;
inline bool AckNewFZUser::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckNewFZUser::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckNewFZUser::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckNewFZUser::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 AckNewFZUser::seqno() const {
  return seqno_;
}
inline void AckNewFZUser::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required int32 result = 2;
inline bool AckNewFZUser::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckNewFZUser::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckNewFZUser::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckNewFZUser::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 AckNewFZUser::result() const {
  return result_;
}
inline void AckNewFZUser::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional string check = 3;
inline bool AckNewFZUser::has_check() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckNewFZUser::set_has_check() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckNewFZUser::clear_has_check() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckNewFZUser::clear_check() {
  if (check_ != &::google::protobuf::internal::kEmptyString) {
    check_->clear();
  }
  clear_has_check();
}
inline const ::std::string& AckNewFZUser::check() const {
  return *check_;
}
inline void AckNewFZUser::set_check(const ::std::string& value) {
  set_has_check();
  if (check_ == &::google::protobuf::internal::kEmptyString) {
    check_ = new ::std::string;
  }
  check_->assign(value);
}
inline void AckNewFZUser::set_check(const char* value) {
  set_has_check();
  if (check_ == &::google::protobuf::internal::kEmptyString) {
    check_ = new ::std::string;
  }
  check_->assign(value);
}
inline void AckNewFZUser::set_check(const char* value, size_t size) {
  set_has_check();
  if (check_ == &::google::protobuf::internal::kEmptyString) {
    check_ = new ::std::string;
  }
  check_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckNewFZUser::mutable_check() {
  set_has_check();
  if (check_ == &::google::protobuf::internal::kEmptyString) {
    check_ = new ::std::string;
  }
  return check_;
}
inline ::std::string* AckNewFZUser::release_check() {
  clear_has_check();
  if (check_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = check_;
    check_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AckNewFZUser::set_allocated_check(::std::string* check) {
  if (check_ != &::google::protobuf::internal::kEmptyString) {
    delete check_;
  }
  if (check) {
    set_has_check();
    check_ = check;
  } else {
    clear_has_check();
    check_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RequestFZUserIdentity

// required uint32 seqno = 1;
inline bool RequestFZUserIdentity::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestFZUserIdentity::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestFZUserIdentity::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestFZUserIdentity::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 RequestFZUserIdentity::seqno() const {
  return seqno_;
}
inline void RequestFZUserIdentity::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required string user = 2;
inline bool RequestFZUserIdentity::has_user() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestFZUserIdentity::set_has_user() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestFZUserIdentity::clear_has_user() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestFZUserIdentity::clear_user() {
  if (user_ != &::google::protobuf::internal::kEmptyString) {
    user_->clear();
  }
  clear_has_user();
}
inline const ::std::string& RequestFZUserIdentity::user() const {
  return *user_;
}
inline void RequestFZUserIdentity::set_user(const ::std::string& value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void RequestFZUserIdentity::set_user(const char* value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void RequestFZUserIdentity::set_user(const char* value, size_t size) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestFZUserIdentity::mutable_user() {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  return user_;
}
inline ::std::string* RequestFZUserIdentity::release_user() {
  clear_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_;
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestFZUserIdentity::set_allocated_user(::std::string* user) {
  if (user_ != &::google::protobuf::internal::kEmptyString) {
    delete user_;
  }
  if (user) {
    set_has_user();
    user_ = user;
  } else {
    clear_has_user();
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string pswd = 3;
inline bool RequestFZUserIdentity::has_pswd() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestFZUserIdentity::set_has_pswd() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestFZUserIdentity::clear_has_pswd() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestFZUserIdentity::clear_pswd() {
  if (pswd_ != &::google::protobuf::internal::kEmptyString) {
    pswd_->clear();
  }
  clear_has_pswd();
}
inline const ::std::string& RequestFZUserIdentity::pswd() const {
  return *pswd_;
}
inline void RequestFZUserIdentity::set_pswd(const ::std::string& value) {
  set_has_pswd();
  if (pswd_ == &::google::protobuf::internal::kEmptyString) {
    pswd_ = new ::std::string;
  }
  pswd_->assign(value);
}
inline void RequestFZUserIdentity::set_pswd(const char* value) {
  set_has_pswd();
  if (pswd_ == &::google::protobuf::internal::kEmptyString) {
    pswd_ = new ::std::string;
  }
  pswd_->assign(value);
}
inline void RequestFZUserIdentity::set_pswd(const char* value, size_t size) {
  set_has_pswd();
  if (pswd_ == &::google::protobuf::internal::kEmptyString) {
    pswd_ = new ::std::string;
  }
  pswd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestFZUserIdentity::mutable_pswd() {
  set_has_pswd();
  if (pswd_ == &::google::protobuf::internal::kEmptyString) {
    pswd_ = new ::std::string;
  }
  return pswd_;
}
inline ::std::string* RequestFZUserIdentity::release_pswd() {
  clear_has_pswd();
  if (pswd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pswd_;
    pswd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestFZUserIdentity::set_allocated_pswd(::std::string* pswd) {
  if (pswd_ != &::google::protobuf::internal::kEmptyString) {
    delete pswd_;
  }
  if (pswd) {
    set_has_pswd();
    pswd_ = pswd;
  } else {
    clear_has_pswd();
    pswd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string pcsn = 4;
inline bool RequestFZUserIdentity::has_pcsn() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestFZUserIdentity::set_has_pcsn() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestFZUserIdentity::clear_has_pcsn() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestFZUserIdentity::clear_pcsn() {
  if (pcsn_ != &::google::protobuf::internal::kEmptyString) {
    pcsn_->clear();
  }
  clear_has_pcsn();
}
inline const ::std::string& RequestFZUserIdentity::pcsn() const {
  return *pcsn_;
}
inline void RequestFZUserIdentity::set_pcsn(const ::std::string& value) {
  set_has_pcsn();
  if (pcsn_ == &::google::protobuf::internal::kEmptyString) {
    pcsn_ = new ::std::string;
  }
  pcsn_->assign(value);
}
inline void RequestFZUserIdentity::set_pcsn(const char* value) {
  set_has_pcsn();
  if (pcsn_ == &::google::protobuf::internal::kEmptyString) {
    pcsn_ = new ::std::string;
  }
  pcsn_->assign(value);
}
inline void RequestFZUserIdentity::set_pcsn(const char* value, size_t size) {
  set_has_pcsn();
  if (pcsn_ == &::google::protobuf::internal::kEmptyString) {
    pcsn_ = new ::std::string;
  }
  pcsn_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestFZUserIdentity::mutable_pcsn() {
  set_has_pcsn();
  if (pcsn_ == &::google::protobuf::internal::kEmptyString) {
    pcsn_ = new ::std::string;
  }
  return pcsn_;
}
inline ::std::string* RequestFZUserIdentity::release_pcsn() {
  clear_has_pcsn();
  if (pcsn_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pcsn_;
    pcsn_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestFZUserIdentity::set_allocated_pcsn(::std::string* pcsn) {
  if (pcsn_ != &::google::protobuf::internal::kEmptyString) {
    delete pcsn_;
  }
  if (pcsn) {
    set_has_pcsn();
    pcsn_ = pcsn;
  } else {
    clear_has_pcsn();
    pcsn_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AckFZUserIdentity

// required uint32 seqno = 1;
inline bool AckFZUserIdentity::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckFZUserIdentity::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckFZUserIdentity::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckFZUserIdentity::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 AckFZUserIdentity::seqno() const {
  return seqno_;
}
inline void AckFZUserIdentity::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required int32 result = 2;
inline bool AckFZUserIdentity::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckFZUserIdentity::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckFZUserIdentity::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckFZUserIdentity::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 AckFZUserIdentity::result() const {
  return result_;
}
inline void AckFZUserIdentity::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// required int32 swver = 3;
inline bool AckFZUserIdentity::has_swver() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckFZUserIdentity::set_has_swver() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckFZUserIdentity::clear_has_swver() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckFZUserIdentity::clear_swver() {
  swver_ = 0;
  clear_has_swver();
}
inline ::google::protobuf::int32 AckFZUserIdentity::swver() const {
  return swver_;
}
inline void AckFZUserIdentity::set_swver(::google::protobuf::int32 value) {
  set_has_swver();
  swver_ = value;
}

// optional string extradata = 4;
inline bool AckFZUserIdentity::has_extradata() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AckFZUserIdentity::set_has_extradata() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AckFZUserIdentity::clear_has_extradata() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AckFZUserIdentity::clear_extradata() {
  if (extradata_ != &::google::protobuf::internal::kEmptyString) {
    extradata_->clear();
  }
  clear_has_extradata();
}
inline const ::std::string& AckFZUserIdentity::extradata() const {
  return *extradata_;
}
inline void AckFZUserIdentity::set_extradata(const ::std::string& value) {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  extradata_->assign(value);
}
inline void AckFZUserIdentity::set_extradata(const char* value) {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  extradata_->assign(value);
}
inline void AckFZUserIdentity::set_extradata(const char* value, size_t size) {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  extradata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckFZUserIdentity::mutable_extradata() {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  return extradata_;
}
inline ::std::string* AckFZUserIdentity::release_extradata() {
  clear_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = extradata_;
    extradata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AckFZUserIdentity::set_allocated_extradata(::std::string* extradata) {
  if (extradata_ != &::google::protobuf::internal::kEmptyString) {
    delete extradata_;
  }
  if (extradata) {
    set_has_extradata();
    extradata_ = extradata;
  } else {
    clear_has_extradata();
    extradata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PostChangeFZPswd

// required uint32 seqno = 1;
inline bool PostChangeFZPswd::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PostChangeFZPswd::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PostChangeFZPswd::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PostChangeFZPswd::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 PostChangeFZPswd::seqno() const {
  return seqno_;
}
inline void PostChangeFZPswd::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required string old = 2;
inline bool PostChangeFZPswd::has_old() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PostChangeFZPswd::set_has_old() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PostChangeFZPswd::clear_has_old() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PostChangeFZPswd::clear_old() {
  if (old_ != &::google::protobuf::internal::kEmptyString) {
    old_->clear();
  }
  clear_has_old();
}
inline const ::std::string& PostChangeFZPswd::old() const {
  return *old_;
}
inline void PostChangeFZPswd::set_old(const ::std::string& value) {
  set_has_old();
  if (old_ == &::google::protobuf::internal::kEmptyString) {
    old_ = new ::std::string;
  }
  old_->assign(value);
}
inline void PostChangeFZPswd::set_old(const char* value) {
  set_has_old();
  if (old_ == &::google::protobuf::internal::kEmptyString) {
    old_ = new ::std::string;
  }
  old_->assign(value);
}
inline void PostChangeFZPswd::set_old(const char* value, size_t size) {
  set_has_old();
  if (old_ == &::google::protobuf::internal::kEmptyString) {
    old_ = new ::std::string;
  }
  old_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PostChangeFZPswd::mutable_old() {
  set_has_old();
  if (old_ == &::google::protobuf::internal::kEmptyString) {
    old_ = new ::std::string;
  }
  return old_;
}
inline ::std::string* PostChangeFZPswd::release_old() {
  clear_has_old();
  if (old_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = old_;
    old_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PostChangeFZPswd::set_allocated_old(::std::string* old) {
  if (old_ != &::google::protobuf::internal::kEmptyString) {
    delete old_;
  }
  if (old) {
    set_has_old();
    old_ = old;
  } else {
    clear_has_old();
    old_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string pswd = 3;
inline bool PostChangeFZPswd::has_pswd() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PostChangeFZPswd::set_has_pswd() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PostChangeFZPswd::clear_has_pswd() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PostChangeFZPswd::clear_pswd() {
  if (pswd_ != &::google::protobuf::internal::kEmptyString) {
    pswd_->clear();
  }
  clear_has_pswd();
}
inline const ::std::string& PostChangeFZPswd::pswd() const {
  return *pswd_;
}
inline void PostChangeFZPswd::set_pswd(const ::std::string& value) {
  set_has_pswd();
  if (pswd_ == &::google::protobuf::internal::kEmptyString) {
    pswd_ = new ::std::string;
  }
  pswd_->assign(value);
}
inline void PostChangeFZPswd::set_pswd(const char* value) {
  set_has_pswd();
  if (pswd_ == &::google::protobuf::internal::kEmptyString) {
    pswd_ = new ::std::string;
  }
  pswd_->assign(value);
}
inline void PostChangeFZPswd::set_pswd(const char* value, size_t size) {
  set_has_pswd();
  if (pswd_ == &::google::protobuf::internal::kEmptyString) {
    pswd_ = new ::std::string;
  }
  pswd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PostChangeFZPswd::mutable_pswd() {
  set_has_pswd();
  if (pswd_ == &::google::protobuf::internal::kEmptyString) {
    pswd_ = new ::std::string;
  }
  return pswd_;
}
inline ::std::string* PostChangeFZPswd::release_pswd() {
  clear_has_pswd();
  if (pswd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pswd_;
    pswd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PostChangeFZPswd::set_allocated_pswd(::std::string* pswd) {
  if (pswd_ != &::google::protobuf::internal::kEmptyString) {
    delete pswd_;
  }
  if (pswd) {
    set_has_pswd();
    pswd_ = pswd;
  } else {
    clear_has_pswd();
    pswd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AckChangeFZPswd

// required uint32 seqno = 1;
inline bool AckChangeFZPswd::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckChangeFZPswd::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckChangeFZPswd::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckChangeFZPswd::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 AckChangeFZPswd::seqno() const {
  return seqno_;
}
inline void AckChangeFZPswd::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required int32 result = 2;
inline bool AckChangeFZPswd::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckChangeFZPswd::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckChangeFZPswd::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckChangeFZPswd::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 AckChangeFZPswd::result() const {
  return result_;
}
inline void AckChangeFZPswd::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// FZUserMessage

// required uint32 seqno = 1;
inline bool FZUserMessage::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FZUserMessage::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FZUserMessage::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FZUserMessage::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 FZUserMessage::seqno() const {
  return seqno_;
}
inline void FZUserMessage::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required .das.proto.FZMsgType type = 2;
inline bool FZUserMessage::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FZUserMessage::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FZUserMessage::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FZUserMessage::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::das::proto::FZMsgType FZUserMessage::type() const {
  return static_cast< ::das::proto::FZMsgType >(type_);
}
inline void FZUserMessage::set_type(::das::proto::FZMsgType value) {
  assert(::das::proto::FZMsgType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required string from = 3;
inline bool FZUserMessage::has_from() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FZUserMessage::set_has_from() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FZUserMessage::clear_has_from() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FZUserMessage::clear_from() {
  if (from_ != &::google::protobuf::internal::kEmptyString) {
    from_->clear();
  }
  clear_has_from();
}
inline const ::std::string& FZUserMessage::from() const {
  return *from_;
}
inline void FZUserMessage::set_from(const ::std::string& value) {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  from_->assign(value);
}
inline void FZUserMessage::set_from(const char* value) {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  from_->assign(value);
}
inline void FZUserMessage::set_from(const char* value, size_t size) {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  from_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FZUserMessage::mutable_from() {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  return from_;
}
inline ::std::string* FZUserMessage::release_from() {
  clear_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = from_;
    from_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FZUserMessage::set_allocated_from(::std::string* from) {
  if (from_ != &::google::protobuf::internal::kEmptyString) {
    delete from_;
  }
  if (from) {
    set_has_from();
    from_ = from;
  } else {
    clear_has_from();
    from_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string to = 4;
inline bool FZUserMessage::has_to() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FZUserMessage::set_has_to() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FZUserMessage::clear_has_to() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FZUserMessage::clear_to() {
  if (to_ != &::google::protobuf::internal::kEmptyString) {
    to_->clear();
  }
  clear_has_to();
}
inline const ::std::string& FZUserMessage::to() const {
  return *to_;
}
inline void FZUserMessage::set_to(const ::std::string& value) {
  set_has_to();
  if (to_ == &::google::protobuf::internal::kEmptyString) {
    to_ = new ::std::string;
  }
  to_->assign(value);
}
inline void FZUserMessage::set_to(const char* value) {
  set_has_to();
  if (to_ == &::google::protobuf::internal::kEmptyString) {
    to_ = new ::std::string;
  }
  to_->assign(value);
}
inline void FZUserMessage::set_to(const char* value, size_t size) {
  set_has_to();
  if (to_ == &::google::protobuf::internal::kEmptyString) {
    to_ = new ::std::string;
  }
  to_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FZUserMessage::mutable_to() {
  set_has_to();
  if (to_ == &::google::protobuf::internal::kEmptyString) {
    to_ = new ::std::string;
  }
  return to_;
}
inline ::std::string* FZUserMessage::release_to() {
  clear_has_to();
  if (to_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = to_;
    to_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FZUserMessage::set_allocated_to(::std::string* to) {
  if (to_ != &::google::protobuf::internal::kEmptyString) {
    delete to_;
  }
  if (to) {
    set_has_to();
    to_ = to;
  } else {
    clear_has_to();
    to_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes content = 5;
inline bool FZUserMessage::has_content() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FZUserMessage::set_has_content() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FZUserMessage::clear_has_content() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FZUserMessage::clear_content() {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& FZUserMessage::content() const {
  return *content_;
}
inline void FZUserMessage::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void FZUserMessage::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void FZUserMessage::set_content(const void* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FZUserMessage::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  return content_;
}
inline ::std::string* FZUserMessage::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FZUserMessage::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AckFZUserMessage

// required uint32 seqno = 1;
inline bool AckFZUserMessage::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckFZUserMessage::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckFZUserMessage::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckFZUserMessage::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 AckFZUserMessage::seqno() const {
  return seqno_;
}
inline void AckFZUserMessage::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required uint32 res = 2;
inline bool AckFZUserMessage::has_res() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckFZUserMessage::set_has_res() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckFZUserMessage::clear_has_res() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckFZUserMessage::clear_res() {
  res_ = 0u;
  clear_has_res();
}
inline ::google::protobuf::uint32 AckFZUserMessage::res() const {
  return res_;
}
inline void AckFZUserMessage::set_res(::google::protobuf::uint32 value) {
  set_has_res();
  res_ = value;
}

// required string user = 3;
inline bool AckFZUserMessage::has_user() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckFZUserMessage::set_has_user() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckFZUserMessage::clear_has_user() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckFZUserMessage::clear_user() {
  if (user_ != &::google::protobuf::internal::kEmptyString) {
    user_->clear();
  }
  clear_has_user();
}
inline const ::std::string& AckFZUserMessage::user() const {
  return *user_;
}
inline void AckFZUserMessage::set_user(const ::std::string& value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void AckFZUserMessage::set_user(const char* value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void AckFZUserMessage::set_user(const char* value, size_t size) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckFZUserMessage::mutable_user() {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  return user_;
}
inline ::std::string* AckFZUserMessage::release_user() {
  clear_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_;
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AckFZUserMessage::set_allocated_user(::std::string* user) {
  if (user_ != &::google::protobuf::internal::kEmptyString) {
    delete user_;
  }
  if (user) {
    set_has_user();
    user_ = user;
  } else {
    clear_has_user();
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RequestFriends

// required uint32 seqno = 1;
inline bool RequestFriends::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestFriends::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestFriends::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestFriends::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 RequestFriends::seqno() const {
  return seqno_;
}
inline void RequestFriends::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// -------------------------------------------------------------------

// AckFriends

// required uint32 seqno = 1;
inline bool AckFriends::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckFriends::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckFriends::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckFriends::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 AckFriends::seqno() const {
  return seqno_;
}
inline void AckFriends::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// repeated string friends = 2;
inline int AckFriends::friends_size() const {
  return friends_.size();
}
inline void AckFriends::clear_friends() {
  friends_.Clear();
}
inline const ::std::string& AckFriends::friends(int index) const {
  return friends_.Get(index);
}
inline ::std::string* AckFriends::mutable_friends(int index) {
  return friends_.Mutable(index);
}
inline void AckFriends::set_friends(int index, const ::std::string& value) {
  friends_.Mutable(index)->assign(value);
}
inline void AckFriends::set_friends(int index, const char* value) {
  friends_.Mutable(index)->assign(value);
}
inline void AckFriends::set_friends(int index, const char* value, size_t size) {
  friends_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckFriends::add_friends() {
  return friends_.Add();
}
inline void AckFriends::add_friends(const ::std::string& value) {
  friends_.Add()->assign(value);
}
inline void AckFriends::add_friends(const char* value) {
  friends_.Add()->assign(value);
}
inline void AckFriends::add_friends(const char* value, size_t size) {
  friends_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
AckFriends::friends() const {
  return friends_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
AckFriends::mutable_friends() {
  return &friends_;
}

// -------------------------------------------------------------------

// AddSWKey

// required uint32 seqno = 1;
inline bool AddSWKey::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddSWKey::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddSWKey::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AddSWKey::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 AddSWKey::seqno() const {
  return seqno_;
}
inline void AddSWKey::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required string swkey = 2;
inline bool AddSWKey::has_swkey() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AddSWKey::set_has_swkey() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AddSWKey::clear_has_swkey() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AddSWKey::clear_swkey() {
  if (swkey_ != &::google::protobuf::internal::kEmptyString) {
    swkey_->clear();
  }
  clear_has_swkey();
}
inline const ::std::string& AddSWKey::swkey() const {
  return *swkey_;
}
inline void AddSWKey::set_swkey(const ::std::string& value) {
  set_has_swkey();
  if (swkey_ == &::google::protobuf::internal::kEmptyString) {
    swkey_ = new ::std::string;
  }
  swkey_->assign(value);
}
inline void AddSWKey::set_swkey(const char* value) {
  set_has_swkey();
  if (swkey_ == &::google::protobuf::internal::kEmptyString) {
    swkey_ = new ::std::string;
  }
  swkey_->assign(value);
}
inline void AddSWKey::set_swkey(const char* value, size_t size) {
  set_has_swkey();
  if (swkey_ == &::google::protobuf::internal::kEmptyString) {
    swkey_ = new ::std::string;
  }
  swkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AddSWKey::mutable_swkey() {
  set_has_swkey();
  if (swkey_ == &::google::protobuf::internal::kEmptyString) {
    swkey_ = new ::std::string;
  }
  return swkey_;
}
inline ::std::string* AddSWKey::release_swkey() {
  clear_has_swkey();
  if (swkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = swkey_;
    swkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AddSWKey::set_allocated_swkey(::std::string* swkey) {
  if (swkey_ != &::google::protobuf::internal::kEmptyString) {
    delete swkey_;
  }
  if (swkey) {
    set_has_swkey();
    swkey_ = swkey;
  } else {
    clear_has_swkey();
    swkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 ver = 3;
inline bool AddSWKey::has_ver() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AddSWKey::set_has_ver() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AddSWKey::clear_has_ver() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AddSWKey::clear_ver() {
  ver_ = 0u;
  clear_has_ver();
}
inline ::google::protobuf::uint32 AddSWKey::ver() const {
  return ver_;
}
inline void AddSWKey::set_ver(::google::protobuf::uint32 value) {
  set_has_ver();
  ver_ = value;
}

// -------------------------------------------------------------------

// AckAddSWKey

// required uint32 seqno = 1;
inline bool AckAddSWKey::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckAddSWKey::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckAddSWKey::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckAddSWKey::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 AckAddSWKey::seqno() const {
  return seqno_;
}
inline void AckAddSWKey::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required int32 result = 2;
inline bool AckAddSWKey::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckAddSWKey::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckAddSWKey::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckAddSWKey::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 AckAddSWKey::result() const {
  return result_;
}
inline void AckAddSWKey::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// SWRegist

// required uint32 seqno = 1;
inline bool SWRegist::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SWRegist::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SWRegist::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SWRegist::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 SWRegist::seqno() const {
  return seqno_;
}
inline void SWRegist::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required string pcsn = 2;
inline bool SWRegist::has_pcsn() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SWRegist::set_has_pcsn() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SWRegist::clear_has_pcsn() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SWRegist::clear_pcsn() {
  if (pcsn_ != &::google::protobuf::internal::kEmptyString) {
    pcsn_->clear();
  }
  clear_has_pcsn();
}
inline const ::std::string& SWRegist::pcsn() const {
  return *pcsn_;
}
inline void SWRegist::set_pcsn(const ::std::string& value) {
  set_has_pcsn();
  if (pcsn_ == &::google::protobuf::internal::kEmptyString) {
    pcsn_ = new ::std::string;
  }
  pcsn_->assign(value);
}
inline void SWRegist::set_pcsn(const char* value) {
  set_has_pcsn();
  if (pcsn_ == &::google::protobuf::internal::kEmptyString) {
    pcsn_ = new ::std::string;
  }
  pcsn_->assign(value);
}
inline void SWRegist::set_pcsn(const char* value, size_t size) {
  set_has_pcsn();
  if (pcsn_ == &::google::protobuf::internal::kEmptyString) {
    pcsn_ = new ::std::string;
  }
  pcsn_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SWRegist::mutable_pcsn() {
  set_has_pcsn();
  if (pcsn_ == &::google::protobuf::internal::kEmptyString) {
    pcsn_ = new ::std::string;
  }
  return pcsn_;
}
inline ::std::string* SWRegist::release_pcsn() {
  clear_has_pcsn();
  if (pcsn_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pcsn_;
    pcsn_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SWRegist::set_allocated_pcsn(::std::string* pcsn) {
  if (pcsn_ != &::google::protobuf::internal::kEmptyString) {
    delete pcsn_;
  }
  if (pcsn) {
    set_has_pcsn();
    pcsn_ = pcsn;
  } else {
    clear_has_pcsn();
    pcsn_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string swkey = 3;
inline bool SWRegist::has_swkey() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SWRegist::set_has_swkey() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SWRegist::clear_has_swkey() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SWRegist::clear_swkey() {
  if (swkey_ != &::google::protobuf::internal::kEmptyString) {
    swkey_->clear();
  }
  clear_has_swkey();
}
inline const ::std::string& SWRegist::swkey() const {
  return *swkey_;
}
inline void SWRegist::set_swkey(const ::std::string& value) {
  set_has_swkey();
  if (swkey_ == &::google::protobuf::internal::kEmptyString) {
    swkey_ = new ::std::string;
  }
  swkey_->assign(value);
}
inline void SWRegist::set_swkey(const char* value) {
  set_has_swkey();
  if (swkey_ == &::google::protobuf::internal::kEmptyString) {
    swkey_ = new ::std::string;
  }
  swkey_->assign(value);
}
inline void SWRegist::set_swkey(const char* value, size_t size) {
  set_has_swkey();
  if (swkey_ == &::google::protobuf::internal::kEmptyString) {
    swkey_ = new ::std::string;
  }
  swkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SWRegist::mutable_swkey() {
  set_has_swkey();
  if (swkey_ == &::google::protobuf::internal::kEmptyString) {
    swkey_ = new ::std::string;
  }
  return swkey_;
}
inline ::std::string* SWRegist::release_swkey() {
  clear_has_swkey();
  if (swkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = swkey_;
    swkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SWRegist::set_allocated_swkey(::std::string* swkey) {
  if (swkey_ != &::google::protobuf::internal::kEmptyString) {
    delete swkey_;
  }
  if (swkey) {
    set_has_swkey();
    swkey_ = swkey;
  } else {
    clear_has_swkey();
    swkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 ver = 4;
inline bool SWRegist::has_ver() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SWRegist::set_has_ver() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SWRegist::clear_has_ver() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SWRegist::clear_ver() {
  ver_ = 0u;
  clear_has_ver();
}
inline ::google::protobuf::uint32 SWRegist::ver() const {
  return ver_;
}
inline void SWRegist::set_ver(::google::protobuf::uint32 value) {
  set_has_ver();
  ver_ = value;
}

// -------------------------------------------------------------------

// AckSWRegist

// required uint32 seqno = 1;
inline bool AckSWRegist::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckSWRegist::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckSWRegist::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckSWRegist::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 AckSWRegist::seqno() const {
  return seqno_;
}
inline void AckSWRegist::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required int32 result = 2;
inline bool AckSWRegist::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckSWRegist::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckSWRegist::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckSWRegist::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 AckSWRegist::result() const {
  return result_;
}
inline void AckSWRegist::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// FZResult

// optional int64 id = 1;
inline bool FZResult::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FZResult::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FZResult::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FZResult::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::int64 FZResult::id() const {
  return id_;
}
inline void FZResult::set_id(::google::protobuf::int64 value) {
  set_has_id();
  id_ = value;
}

// optional int64 begTm = 2;
inline bool FZResult::has_begtm() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FZResult::set_has_begtm() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FZResult::clear_has_begtm() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FZResult::clear_begtm() {
  begtm_ = GOOGLE_LONGLONG(0);
  clear_has_begtm();
}
inline ::google::protobuf::int64 FZResult::begtm() const {
  return begtm_;
}
inline void FZResult::set_begtm(::google::protobuf::int64 value) {
  set_has_begtm();
  begtm_ = value;
}

// required int32 usedTm = 3;
inline bool FZResult::has_usedtm() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FZResult::set_has_usedtm() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FZResult::clear_has_usedtm() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FZResult::clear_usedtm() {
  usedtm_ = 0;
  clear_has_usedtm();
}
inline ::google::protobuf::int32 FZResult::usedtm() const {
  return usedtm_;
}
inline void FZResult::set_usedtm(::google::protobuf::int32 value) {
  set_has_usedtm();
  usedtm_ = value;
}

// required int32 type = 4;
inline bool FZResult::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FZResult::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FZResult::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FZResult::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 FZResult::type() const {
  return type_;
}
inline void FZResult::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required int32 rslt = 5;
inline bool FZResult::has_rslt() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FZResult::set_has_rslt() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FZResult::clear_has_rslt() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FZResult::clear_rslt() {
  rslt_ = 0;
  clear_has_rslt();
}
inline ::google::protobuf::int32 FZResult::rslt() const {
  return rslt_;
}
inline void FZResult::set_rslt(::google::protobuf::int32 value) {
  set_has_rslt();
  rslt_ = value;
}

// -------------------------------------------------------------------

// PostFZResult

// required uint32 seqno = 1;
inline bool PostFZResult::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PostFZResult::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PostFZResult::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PostFZResult::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 PostFZResult::seqno() const {
  return seqno_;
}
inline void PostFZResult::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required .das.proto.FZResult rslt = 2;
inline bool PostFZResult::has_rslt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PostFZResult::set_has_rslt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PostFZResult::clear_has_rslt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PostFZResult::clear_rslt() {
  if (rslt_ != NULL) rslt_->::das::proto::FZResult::Clear();
  clear_has_rslt();
}
inline const ::das::proto::FZResult& PostFZResult::rslt() const {
  return rslt_ != NULL ? *rslt_ : *default_instance_->rslt_;
}
inline ::das::proto::FZResult* PostFZResult::mutable_rslt() {
  set_has_rslt();
  if (rslt_ == NULL) rslt_ = new ::das::proto::FZResult;
  return rslt_;
}
inline ::das::proto::FZResult* PostFZResult::release_rslt() {
  clear_has_rslt();
  ::das::proto::FZResult* temp = rslt_;
  rslt_ = NULL;
  return temp;
}
inline void PostFZResult::set_allocated_rslt(::das::proto::FZResult* rslt) {
  delete rslt_;
  rslt_ = rslt;
  if (rslt) {
    set_has_rslt();
  } else {
    clear_has_rslt();
  }
}

// -------------------------------------------------------------------

// AckPostFZResult

// required uint32 seqno = 1;
inline bool AckPostFZResult::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckPostFZResult::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckPostFZResult::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckPostFZResult::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 AckPostFZResult::seqno() const {
  return seqno_;
}
inline void AckPostFZResult::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required int64 id = 2;
inline bool AckPostFZResult::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckPostFZResult::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckPostFZResult::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckPostFZResult::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::int64 AckPostFZResult::id() const {
  return id_;
}
inline void AckPostFZResult::set_id(::google::protobuf::int64 value) {
  set_has_id();
  id_ = value;
}

// -------------------------------------------------------------------

// RequestFZResults

// required uint32 seqno = 1;
inline bool RequestFZResults::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestFZResults::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestFZResults::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestFZResults::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 RequestFZResults::seqno() const {
  return seqno_;
}
inline void RequestFZResults::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// optional int64 tmbeg = 2;
inline bool RequestFZResults::has_tmbeg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestFZResults::set_has_tmbeg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestFZResults::clear_has_tmbeg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestFZResults::clear_tmbeg() {
  tmbeg_ = GOOGLE_LONGLONG(0);
  clear_has_tmbeg();
}
inline ::google::protobuf::int64 RequestFZResults::tmbeg() const {
  return tmbeg_;
}
inline void RequestFZResults::set_tmbeg(::google::protobuf::int64 value) {
  set_has_tmbeg();
  tmbeg_ = value;
}

// optional int64 tmend = 3;
inline bool RequestFZResults::has_tmend() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestFZResults::set_has_tmend() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestFZResults::clear_has_tmend() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestFZResults::clear_tmend() {
  tmend_ = GOOGLE_LONGLONG(0);
  clear_has_tmend();
}
inline ::google::protobuf::int64 RequestFZResults::tmend() const {
  return tmend_;
}
inline void RequestFZResults::set_tmend(::google::protobuf::int64 value) {
  set_has_tmend();
  tmend_ = value;
}

// -------------------------------------------------------------------

// AckFZResults

// required uint32 seqno = 1;
inline bool AckFZResults::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckFZResults::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckFZResults::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckFZResults::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 AckFZResults::seqno() const {
  return seqno_;
}
inline void AckFZResults::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// repeated .das.proto.FZResult rslt = 2;
inline int AckFZResults::rslt_size() const {
  return rslt_.size();
}
inline void AckFZResults::clear_rslt() {
  rslt_.Clear();
}
inline const ::das::proto::FZResult& AckFZResults::rslt(int index) const {
  return rslt_.Get(index);
}
inline ::das::proto::FZResult* AckFZResults::mutable_rslt(int index) {
  return rslt_.Mutable(index);
}
inline ::das::proto::FZResult* AckFZResults::add_rslt() {
  return rslt_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::das::proto::FZResult >&
AckFZResults::rslt() const {
  return rslt_;
}
inline ::google::protobuf::RepeatedPtrField< ::das::proto::FZResult >*
AckFZResults::mutable_rslt() {
  return &rslt_;
}

// -------------------------------------------------------------------

// FZInfo

// optional string name = 1;
inline bool FZInfo::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FZInfo::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FZInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FZInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& FZInfo::name() const {
  return *name_;
}
inline void FZInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void FZInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void FZInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FZInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* FZInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FZInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string grade = 2;
inline bool FZInfo::has_grade() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FZInfo::set_has_grade() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FZInfo::clear_has_grade() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FZInfo::clear_grade() {
  if (grade_ != &::google::protobuf::internal::kEmptyString) {
    grade_->clear();
  }
  clear_has_grade();
}
inline const ::std::string& FZInfo::grade() const {
  return *grade_;
}
inline void FZInfo::set_grade(const ::std::string& value) {
  set_has_grade();
  if (grade_ == &::google::protobuf::internal::kEmptyString) {
    grade_ = new ::std::string;
  }
  grade_->assign(value);
}
inline void FZInfo::set_grade(const char* value) {
  set_has_grade();
  if (grade_ == &::google::protobuf::internal::kEmptyString) {
    grade_ = new ::std::string;
  }
  grade_->assign(value);
}
inline void FZInfo::set_grade(const char* value, size_t size) {
  set_has_grade();
  if (grade_ == &::google::protobuf::internal::kEmptyString) {
    grade_ = new ::std::string;
  }
  grade_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FZInfo::mutable_grade() {
  set_has_grade();
  if (grade_ == &::google::protobuf::internal::kEmptyString) {
    grade_ = new ::std::string;
  }
  return grade_;
}
inline ::std::string* FZInfo::release_grade() {
  clear_has_grade();
  if (grade_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = grade_;
    grade_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FZInfo::set_allocated_grade(::std::string* grade) {
  if (grade_ != &::google::protobuf::internal::kEmptyString) {
    delete grade_;
  }
  if (grade) {
    set_has_grade();
    grade_ = grade;
  } else {
    clear_has_grade();
    grade_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string majr = 3;
inline bool FZInfo::has_majr() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FZInfo::set_has_majr() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FZInfo::clear_has_majr() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FZInfo::clear_majr() {
  if (majr_ != &::google::protobuf::internal::kEmptyString) {
    majr_->clear();
  }
  clear_has_majr();
}
inline const ::std::string& FZInfo::majr() const {
  return *majr_;
}
inline void FZInfo::set_majr(const ::std::string& value) {
  set_has_majr();
  if (majr_ == &::google::protobuf::internal::kEmptyString) {
    majr_ = new ::std::string;
  }
  majr_->assign(value);
}
inline void FZInfo::set_majr(const char* value) {
  set_has_majr();
  if (majr_ == &::google::protobuf::internal::kEmptyString) {
    majr_ = new ::std::string;
  }
  majr_->assign(value);
}
inline void FZInfo::set_majr(const char* value, size_t size) {
  set_has_majr();
  if (majr_ == &::google::protobuf::internal::kEmptyString) {
    majr_ = new ::std::string;
  }
  majr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FZInfo::mutable_majr() {
  set_has_majr();
  if (majr_ == &::google::protobuf::internal::kEmptyString) {
    majr_ = new ::std::string;
  }
  return majr_;
}
inline ::std::string* FZInfo::release_majr() {
  clear_has_majr();
  if (majr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = majr_;
    majr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FZInfo::set_allocated_majr(::std::string* majr) {
  if (majr_ != &::google::protobuf::internal::kEmptyString) {
    delete majr_;
  }
  if (majr) {
    set_has_majr();
    majr_ = majr;
  } else {
    clear_has_majr();
    majr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string id = 4;
inline bool FZInfo::has_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FZInfo::set_has_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FZInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FZInfo::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& FZInfo::id() const {
  return *id_;
}
inline void FZInfo::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void FZInfo::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void FZInfo::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FZInfo::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* FZInfo::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FZInfo::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string school = 5;
inline bool FZInfo::has_school() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FZInfo::set_has_school() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FZInfo::clear_has_school() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FZInfo::clear_school() {
  if (school_ != &::google::protobuf::internal::kEmptyString) {
    school_->clear();
  }
  clear_has_school();
}
inline const ::std::string& FZInfo::school() const {
  return *school_;
}
inline void FZInfo::set_school(const ::std::string& value) {
  set_has_school();
  if (school_ == &::google::protobuf::internal::kEmptyString) {
    school_ = new ::std::string;
  }
  school_->assign(value);
}
inline void FZInfo::set_school(const char* value) {
  set_has_school();
  if (school_ == &::google::protobuf::internal::kEmptyString) {
    school_ = new ::std::string;
  }
  school_->assign(value);
}
inline void FZInfo::set_school(const char* value, size_t size) {
  set_has_school();
  if (school_ == &::google::protobuf::internal::kEmptyString) {
    school_ = new ::std::string;
  }
  school_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FZInfo::mutable_school() {
  set_has_school();
  if (school_ == &::google::protobuf::internal::kEmptyString) {
    school_ = new ::std::string;
  }
  return school_;
}
inline ::std::string* FZInfo::release_school() {
  clear_has_school();
  if (school_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = school_;
    school_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FZInfo::set_allocated_school(::std::string* school) {
  if (school_ != &::google::protobuf::internal::kEmptyString) {
    delete school_;
  }
  if (school) {
    set_has_school();
    school_ = school;
  } else {
    clear_has_school();
    school_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string births = 6;
inline bool FZInfo::has_births() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FZInfo::set_has_births() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FZInfo::clear_has_births() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FZInfo::clear_births() {
  if (births_ != &::google::protobuf::internal::kEmptyString) {
    births_->clear();
  }
  clear_has_births();
}
inline const ::std::string& FZInfo::births() const {
  return *births_;
}
inline void FZInfo::set_births(const ::std::string& value) {
  set_has_births();
  if (births_ == &::google::protobuf::internal::kEmptyString) {
    births_ = new ::std::string;
  }
  births_->assign(value);
}
inline void FZInfo::set_births(const char* value) {
  set_has_births();
  if (births_ == &::google::protobuf::internal::kEmptyString) {
    births_ = new ::std::string;
  }
  births_->assign(value);
}
inline void FZInfo::set_births(const char* value, size_t size) {
  set_has_births();
  if (births_ == &::google::protobuf::internal::kEmptyString) {
    births_ = new ::std::string;
  }
  births_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FZInfo::mutable_births() {
  set_has_births();
  if (births_ == &::google::protobuf::internal::kEmptyString) {
    births_ = new ::std::string;
  }
  return births_;
}
inline ::std::string* FZInfo::release_births() {
  clear_has_births();
  if (births_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = births_;
    births_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FZInfo::set_allocated_births(::std::string* births) {
  if (births_ != &::google::protobuf::internal::kEmptyString) {
    delete births_;
  }
  if (births) {
    set_has_births();
    births_ = births;
  } else {
    clear_has_births();
    births_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string email = 7;
inline bool FZInfo::has_email() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void FZInfo::set_has_email() {
  _has_bits_[0] |= 0x00000040u;
}
inline void FZInfo::clear_has_email() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void FZInfo::clear_email() {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    email_->clear();
  }
  clear_has_email();
}
inline const ::std::string& FZInfo::email() const {
  return *email_;
}
inline void FZInfo::set_email(const ::std::string& value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void FZInfo::set_email(const char* value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void FZInfo::set_email(const char* value, size_t size) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FZInfo::mutable_email() {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  return email_;
}
inline ::std::string* FZInfo::release_email() {
  clear_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = email_;
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FZInfo::set_allocated_email(::std::string* email) {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    delete email_;
  }
  if (email) {
    set_has_email();
    email_ = email;
  } else {
    clear_has_email();
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PostFZInfo

// required uint32 seqno = 1;
inline bool PostFZInfo::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PostFZInfo::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PostFZInfo::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PostFZInfo::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 PostFZInfo::seqno() const {
  return seqno_;
}
inline void PostFZInfo::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required .das.proto.FZInfo info = 2;
inline bool PostFZInfo::has_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PostFZInfo::set_has_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PostFZInfo::clear_has_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PostFZInfo::clear_info() {
  if (info_ != NULL) info_->::das::proto::FZInfo::Clear();
  clear_has_info();
}
inline const ::das::proto::FZInfo& PostFZInfo::info() const {
  return info_ != NULL ? *info_ : *default_instance_->info_;
}
inline ::das::proto::FZInfo* PostFZInfo::mutable_info() {
  set_has_info();
  if (info_ == NULL) info_ = new ::das::proto::FZInfo;
  return info_;
}
inline ::das::proto::FZInfo* PostFZInfo::release_info() {
  clear_has_info();
  ::das::proto::FZInfo* temp = info_;
  info_ = NULL;
  return temp;
}
inline void PostFZInfo::set_allocated_info(::das::proto::FZInfo* info) {
  delete info_;
  info_ = info;
  if (info) {
    set_has_info();
  } else {
    clear_has_info();
  }
}

// -------------------------------------------------------------------

// AckPostFZInfo

// required uint32 seqno = 1;
inline bool AckPostFZInfo::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckPostFZInfo::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckPostFZInfo::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckPostFZInfo::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 AckPostFZInfo::seqno() const {
  return seqno_;
}
inline void AckPostFZInfo::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required int32 rslt = 2;
inline bool AckPostFZInfo::has_rslt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckPostFZInfo::set_has_rslt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckPostFZInfo::clear_has_rslt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckPostFZInfo::clear_rslt() {
  rslt_ = 0;
  clear_has_rslt();
}
inline ::google::protobuf::int32 AckPostFZInfo::rslt() const {
  return rslt_;
}
inline void AckPostFZInfo::set_rslt(::google::protobuf::int32 value) {
  set_has_rslt();
  rslt_ = value;
}

// -------------------------------------------------------------------

// RequestFZInfo

// required uint32 seqno = 1;
inline bool RequestFZInfo::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestFZInfo::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestFZInfo::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestFZInfo::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 RequestFZInfo::seqno() const {
  return seqno_;
}
inline void RequestFZInfo::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// -------------------------------------------------------------------

// AckFZInfo

// required uint32 seqno = 1;
inline bool AckFZInfo::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckFZInfo::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckFZInfo::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckFZInfo::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 AckFZInfo::seqno() const {
  return seqno_;
}
inline void AckFZInfo::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// optional .das.proto.FZInfo info = 2;
inline bool AckFZInfo::has_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckFZInfo::set_has_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckFZInfo::clear_has_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckFZInfo::clear_info() {
  if (info_ != NULL) info_->::das::proto::FZInfo::Clear();
  clear_has_info();
}
inline const ::das::proto::FZInfo& AckFZInfo::info() const {
  return info_ != NULL ? *info_ : *default_instance_->info_;
}
inline ::das::proto::FZInfo* AckFZInfo::mutable_info() {
  set_has_info();
  if (info_ == NULL) info_ = new ::das::proto::FZInfo;
  return info_;
}
inline ::das::proto::FZInfo* AckFZInfo::release_info() {
  clear_has_info();
  ::das::proto::FZInfo* temp = info_;
  info_ = NULL;
  return temp;
}
inline void AckFZInfo::set_allocated_info(::das::proto::FZInfo* info) {
  delete info_;
  info_ = info;
  if (info) {
    set_has_info();
  } else {
    clear_has_info();
  }
}

// -------------------------------------------------------------------

// PostGetFZPswd

// required uint32 seqno = 1;
inline bool PostGetFZPswd::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PostGetFZPswd::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PostGetFZPswd::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PostGetFZPswd::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 PostGetFZPswd::seqno() const {
  return seqno_;
}
inline void PostGetFZPswd::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required string email = 2;
inline bool PostGetFZPswd::has_email() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PostGetFZPswd::set_has_email() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PostGetFZPswd::clear_has_email() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PostGetFZPswd::clear_email() {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    email_->clear();
  }
  clear_has_email();
}
inline const ::std::string& PostGetFZPswd::email() const {
  return *email_;
}
inline void PostGetFZPswd::set_email(const ::std::string& value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void PostGetFZPswd::set_email(const char* value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void PostGetFZPswd::set_email(const char* value, size_t size) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PostGetFZPswd::mutable_email() {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  return email_;
}
inline ::std::string* PostGetFZPswd::release_email() {
  clear_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = email_;
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PostGetFZPswd::set_allocated_email(::std::string* email) {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    delete email_;
  }
  if (email) {
    set_has_email();
    email_ = email;
  } else {
    clear_has_email();
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string user = 3;
inline bool PostGetFZPswd::has_user() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PostGetFZPswd::set_has_user() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PostGetFZPswd::clear_has_user() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PostGetFZPswd::clear_user() {
  if (user_ != &::google::protobuf::internal::kEmptyString) {
    user_->clear();
  }
  clear_has_user();
}
inline const ::std::string& PostGetFZPswd::user() const {
  return *user_;
}
inline void PostGetFZPswd::set_user(const ::std::string& value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void PostGetFZPswd::set_user(const char* value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void PostGetFZPswd::set_user(const char* value, size_t size) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PostGetFZPswd::mutable_user() {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  return user_;
}
inline ::std::string* PostGetFZPswd::release_user() {
  clear_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_;
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PostGetFZPswd::set_allocated_user(::std::string* user) {
  if (user_ != &::google::protobuf::internal::kEmptyString) {
    delete user_;
  }
  if (user) {
    set_has_user();
    user_ = user;
  } else {
    clear_has_user();
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AckGetFZPswd

// required uint32 seqno = 1;
inline bool AckGetFZPswd::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckGetFZPswd::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckGetFZPswd::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckGetFZPswd::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 AckGetFZPswd::seqno() const {
  return seqno_;
}
inline void AckGetFZPswd::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required int32 rslt = 2;
inline bool AckGetFZPswd::has_rslt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckGetFZPswd::set_has_rslt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckGetFZPswd::clear_has_rslt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckGetFZPswd::clear_rslt() {
  rslt_ = 0;
  clear_has_rslt();
}
inline ::google::protobuf::int32 AckGetFZPswd::rslt() const {
  return rslt_;
}
inline void AckGetFZPswd::set_rslt(::google::protobuf::int32 value) {
  set_has_rslt();
  rslt_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace das

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::das::proto::FZMsgType>() {
  return ::das::proto::FZMsgType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_das_2eproto__INCLUDED
