// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: das.proto

#ifndef PROTOBUF_das_2eproto__INCLUDED
#define PROTOBUF_das_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace das {
namespace proto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_das_2eproto();
void protobuf_AssignDesc_das_2eproto();
void protobuf_ShutdownFile_das_2eproto();

class RequestTrackerIdentityAuthentication;
class AckTrackerIdentityAuthentication;
class Request3rdIdentityAuthentication;
class Ack3rdIdentityAuthentication;
class RequestUavIdentityAuthentication;
class AckUavIdentityAuthentication;
class GpsInformation;
class OperationStatus;
class OperationParams;
class OperationInformation;
class PostOperationInformation;
class AckOperationInformation;
class RequestIdentityAllocation;
class AckIdentityAllocation;
class PostHeartBeat;
class AckHeartBeat;
class RequestProgramUpgrade;
class AckProgramUpgrade;
class RequestProgramDownload;
class AckProgramDownload;
class ParameterDescription;
class QueryParameters;
class AckQueryParameters;
class ConfigureParameters;
class AckConfigurParameters;
class Coordinate;
class OperationSnapshot;
class PostOperationSnapshot;
class AckPostOperationSnapshot;
class RequestPositionAuthentication;
class AckPositionAuthentication;
class ReportDeviceException;
class AckReportDeviceException;
class RequestGVIdentityAuthentication;
class AckGVIdentityAuthentication;
class RequestIVIdentityAuthentication;
class AckIVIdentityAuthentication;
class UpdateDeviceList;
class AckUpdateDeviceList;
class SyncDeviceList;
class AckSyncDeviceList;

// ===================================================================

class RequestTrackerIdentityAuthentication : public ::google::protobuf::Message {
 public:
  RequestTrackerIdentityAuthentication();
  virtual ~RequestTrackerIdentityAuthentication();

  RequestTrackerIdentityAuthentication(const RequestTrackerIdentityAuthentication& from);

  inline RequestTrackerIdentityAuthentication& operator=(const RequestTrackerIdentityAuthentication& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestTrackerIdentityAuthentication& default_instance();

  void Swap(RequestTrackerIdentityAuthentication* other);

  // implements Message ----------------------------------------------

  RequestTrackerIdentityAuthentication* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestTrackerIdentityAuthentication& from);
  void MergeFrom(const RequestTrackerIdentityAuthentication& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required string trackerid = 2;
  inline bool has_trackerid() const;
  inline void clear_trackerid();
  static const int kTrackeridFieldNumber = 2;
  inline const ::std::string& trackerid() const;
  inline void set_trackerid(const ::std::string& value);
  inline void set_trackerid(const char* value);
  inline void set_trackerid(const char* value, size_t size);
  inline ::std::string* mutable_trackerid();
  inline ::std::string* release_trackerid();
  inline void set_allocated_trackerid(::std::string* trackerid);

  // optional string extradata = 3;
  inline bool has_extradata() const;
  inline void clear_extradata();
  static const int kExtradataFieldNumber = 3;
  inline const ::std::string& extradata() const;
  inline void set_extradata(const ::std::string& value);
  inline void set_extradata(const char* value);
  inline void set_extradata(const char* value, size_t size);
  inline ::std::string* mutable_extradata();
  inline ::std::string* release_extradata();
  inline void set_allocated_extradata(::std::string* extradata);

  // @@protoc_insertion_point(class_scope:das.proto.RequestTrackerIdentityAuthentication)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_trackerid();
  inline void clear_has_trackerid();
  inline void set_has_extradata();
  inline void clear_has_extradata();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* trackerid_;
  ::std::string* extradata_;
  ::google::protobuf::uint32 seqno_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static RequestTrackerIdentityAuthentication* default_instance_;
};
// -------------------------------------------------------------------

class AckTrackerIdentityAuthentication : public ::google::protobuf::Message {
 public:
  AckTrackerIdentityAuthentication();
  virtual ~AckTrackerIdentityAuthentication();

  AckTrackerIdentityAuthentication(const AckTrackerIdentityAuthentication& from);

  inline AckTrackerIdentityAuthentication& operator=(const AckTrackerIdentityAuthentication& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckTrackerIdentityAuthentication& default_instance();

  void Swap(AckTrackerIdentityAuthentication* other);

  // implements Message ----------------------------------------------

  AckTrackerIdentityAuthentication* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckTrackerIdentityAuthentication& from);
  void MergeFrom(const AckTrackerIdentityAuthentication& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional string extradata = 3;
  inline bool has_extradata() const;
  inline void clear_extradata();
  static const int kExtradataFieldNumber = 3;
  inline const ::std::string& extradata() const;
  inline void set_extradata(const ::std::string& value);
  inline void set_extradata(const char* value);
  inline void set_extradata(const char* value, size_t size);
  inline ::std::string* mutable_extradata();
  inline ::std::string* release_extradata();
  inline void set_allocated_extradata(::std::string* extradata);

  // @@protoc_insertion_point(class_scope:das.proto.AckTrackerIdentityAuthentication)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_extradata();
  inline void clear_has_extradata();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 seqno_;
  ::google::protobuf::int32 result_;
  ::std::string* extradata_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static AckTrackerIdentityAuthentication* default_instance_;
};
// -------------------------------------------------------------------

class Request3rdIdentityAuthentication : public ::google::protobuf::Message {
 public:
  Request3rdIdentityAuthentication();
  virtual ~Request3rdIdentityAuthentication();

  Request3rdIdentityAuthentication(const Request3rdIdentityAuthentication& from);

  inline Request3rdIdentityAuthentication& operator=(const Request3rdIdentityAuthentication& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request3rdIdentityAuthentication& default_instance();

  void Swap(Request3rdIdentityAuthentication* other);

  // implements Message ----------------------------------------------

  Request3rdIdentityAuthentication* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request3rdIdentityAuthentication& from);
  void MergeFrom(const Request3rdIdentityAuthentication& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required string identification = 2;
  inline bool has_identification() const;
  inline void clear_identification();
  static const int kIdentificationFieldNumber = 2;
  inline const ::std::string& identification() const;
  inline void set_identification(const ::std::string& value);
  inline void set_identification(const char* value);
  inline void set_identification(const char* value, size_t size);
  inline ::std::string* mutable_identification();
  inline ::std::string* release_identification();
  inline void set_allocated_identification(::std::string* identification);

  // required string secretkey = 3;
  inline bool has_secretkey() const;
  inline void clear_secretkey();
  static const int kSecretkeyFieldNumber = 3;
  inline const ::std::string& secretkey() const;
  inline void set_secretkey(const ::std::string& value);
  inline void set_secretkey(const char* value);
  inline void set_secretkey(const char* value, size_t size);
  inline ::std::string* mutable_secretkey();
  inline ::std::string* release_secretkey();
  inline void set_allocated_secretkey(::std::string* secretkey);

  // optional string extradata = 4;
  inline bool has_extradata() const;
  inline void clear_extradata();
  static const int kExtradataFieldNumber = 4;
  inline const ::std::string& extradata() const;
  inline void set_extradata(const ::std::string& value);
  inline void set_extradata(const char* value);
  inline void set_extradata(const char* value, size_t size);
  inline ::std::string* mutable_extradata();
  inline ::std::string* release_extradata();
  inline void set_allocated_extradata(::std::string* extradata);

  // @@protoc_insertion_point(class_scope:das.proto.Request3rdIdentityAuthentication)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_identification();
  inline void clear_has_identification();
  inline void set_has_secretkey();
  inline void clear_has_secretkey();
  inline void set_has_extradata();
  inline void clear_has_extradata();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* identification_;
  ::std::string* secretkey_;
  ::std::string* extradata_;
  ::google::protobuf::uint32 seqno_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static Request3rdIdentityAuthentication* default_instance_;
};
// -------------------------------------------------------------------

class Ack3rdIdentityAuthentication : public ::google::protobuf::Message {
 public:
  Ack3rdIdentityAuthentication();
  virtual ~Ack3rdIdentityAuthentication();

  Ack3rdIdentityAuthentication(const Ack3rdIdentityAuthentication& from);

  inline Ack3rdIdentityAuthentication& operator=(const Ack3rdIdentityAuthentication& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Ack3rdIdentityAuthentication& default_instance();

  void Swap(Ack3rdIdentityAuthentication* other);

  // implements Message ----------------------------------------------

  Ack3rdIdentityAuthentication* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Ack3rdIdentityAuthentication& from);
  void MergeFrom(const Ack3rdIdentityAuthentication& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional string extradata = 3;
  inline bool has_extradata() const;
  inline void clear_extradata();
  static const int kExtradataFieldNumber = 3;
  inline const ::std::string& extradata() const;
  inline void set_extradata(const ::std::string& value);
  inline void set_extradata(const char* value);
  inline void set_extradata(const char* value, size_t size);
  inline ::std::string* mutable_extradata();
  inline ::std::string* release_extradata();
  inline void set_allocated_extradata(::std::string* extradata);

  // @@protoc_insertion_point(class_scope:das.proto.Ack3rdIdentityAuthentication)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_extradata();
  inline void clear_has_extradata();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 seqno_;
  ::google::protobuf::int32 result_;
  ::std::string* extradata_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static Ack3rdIdentityAuthentication* default_instance_;
};
// -------------------------------------------------------------------

class RequestUavIdentityAuthentication : public ::google::protobuf::Message {
 public:
  RequestUavIdentityAuthentication();
  virtual ~RequestUavIdentityAuthentication();

  RequestUavIdentityAuthentication(const RequestUavIdentityAuthentication& from);

  inline RequestUavIdentityAuthentication& operator=(const RequestUavIdentityAuthentication& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestUavIdentityAuthentication& default_instance();

  void Swap(RequestUavIdentityAuthentication* other);

  // implements Message ----------------------------------------------

  RequestUavIdentityAuthentication* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestUavIdentityAuthentication& from);
  void MergeFrom(const RequestUavIdentityAuthentication& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required string uavid = 2;
  inline bool has_uavid() const;
  inline void clear_uavid();
  static const int kUavidFieldNumber = 2;
  inline const ::std::string& uavid() const;
  inline void set_uavid(const ::std::string& value);
  inline void set_uavid(const char* value);
  inline void set_uavid(const char* value, size_t size);
  inline ::std::string* mutable_uavid();
  inline ::std::string* release_uavid();
  inline void set_allocated_uavid(::std::string* uavid);

  // optional string extradata = 3;
  inline bool has_extradata() const;
  inline void clear_extradata();
  static const int kExtradataFieldNumber = 3;
  inline const ::std::string& extradata() const;
  inline void set_extradata(const ::std::string& value);
  inline void set_extradata(const char* value);
  inline void set_extradata(const char* value, size_t size);
  inline ::std::string* mutable_extradata();
  inline ::std::string* release_extradata();
  inline void set_allocated_extradata(::std::string* extradata);

  // @@protoc_insertion_point(class_scope:das.proto.RequestUavIdentityAuthentication)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_uavid();
  inline void clear_has_uavid();
  inline void set_has_extradata();
  inline void clear_has_extradata();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uavid_;
  ::std::string* extradata_;
  ::google::protobuf::uint32 seqno_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static RequestUavIdentityAuthentication* default_instance_;
};
// -------------------------------------------------------------------

class AckUavIdentityAuthentication : public ::google::protobuf::Message {
 public:
  AckUavIdentityAuthentication();
  virtual ~AckUavIdentityAuthentication();

  AckUavIdentityAuthentication(const AckUavIdentityAuthentication& from);

  inline AckUavIdentityAuthentication& operator=(const AckUavIdentityAuthentication& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckUavIdentityAuthentication& default_instance();

  void Swap(AckUavIdentityAuthentication* other);

  // implements Message ----------------------------------------------

  AckUavIdentityAuthentication* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckUavIdentityAuthentication& from);
  void MergeFrom(const AckUavIdentityAuthentication& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // optional string uavid = 2;
  inline bool has_uavid() const;
  inline void clear_uavid();
  static const int kUavidFieldNumber = 2;
  inline const ::std::string& uavid() const;
  inline void set_uavid(const ::std::string& value);
  inline void set_uavid(const char* value);
  inline void set_uavid(const char* value, size_t size);
  inline ::std::string* mutable_uavid();
  inline ::std::string* release_uavid();
  inline void set_allocated_uavid(::std::string* uavid);

  // required int32 result = 3;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 3;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional uint64 deadline = 4;
  inline bool has_deadline() const;
  inline void clear_deadline();
  static const int kDeadlineFieldNumber = 4;
  inline ::google::protobuf::uint64 deadline() const;
  inline void set_deadline(::google::protobuf::uint64 value);

  // optional string authString = 5;
  inline bool has_authstring() const;
  inline void clear_authstring();
  static const int kAuthStringFieldNumber = 5;
  inline const ::std::string& authstring() const;
  inline void set_authstring(const ::std::string& value);
  inline void set_authstring(const char* value);
  inline void set_authstring(const char* value, size_t size);
  inline ::std::string* mutable_authstring();
  inline ::std::string* release_authstring();
  inline void set_allocated_authstring(::std::string* authstring);

  // @@protoc_insertion_point(class_scope:das.proto.AckUavIdentityAuthentication)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_uavid();
  inline void clear_has_uavid();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_deadline();
  inline void clear_has_deadline();
  inline void set_has_authstring();
  inline void clear_has_authstring();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uavid_;
  ::google::protobuf::uint32 seqno_;
  ::google::protobuf::int32 result_;
  ::google::protobuf::uint64 deadline_;
  ::std::string* authstring_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static AckUavIdentityAuthentication* default_instance_;
};
// -------------------------------------------------------------------

class GpsInformation : public ::google::protobuf::Message {
 public:
  GpsInformation();
  virtual ~GpsInformation();

  GpsInformation(const GpsInformation& from);

  inline GpsInformation& operator=(const GpsInformation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GpsInformation& default_instance();

  void Swap(GpsInformation* other);

  // implements Message ----------------------------------------------

  GpsInformation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GpsInformation& from);
  void MergeFrom(const GpsInformation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 longitude = 1;
  inline bool has_longitude() const;
  inline void clear_longitude();
  static const int kLongitudeFieldNumber = 1;
  inline ::google::protobuf::int32 longitude() const;
  inline void set_longitude(::google::protobuf::int32 value);

  // required int32 latitude = 2;
  inline bool has_latitude() const;
  inline void clear_latitude();
  static const int kLatitudeFieldNumber = 2;
  inline ::google::protobuf::int32 latitude() const;
  inline void set_latitude(::google::protobuf::int32 value);

  // required int32 altitude = 3;
  inline bool has_altitude() const;
  inline void clear_altitude();
  static const int kAltitudeFieldNumber = 3;
  inline ::google::protobuf::int32 altitude() const;
  inline void set_altitude(::google::protobuf::int32 value);

  // repeated float velocity = 4;
  inline int velocity_size() const;
  inline void clear_velocity();
  static const int kVelocityFieldNumber = 4;
  inline float velocity(int index) const;
  inline void set_velocity(int index, float value);
  inline void add_velocity(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      velocity() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_velocity();

  // @@protoc_insertion_point(class_scope:das.proto.GpsInformation)
 private:
  inline void set_has_longitude();
  inline void clear_has_longitude();
  inline void set_has_latitude();
  inline void clear_has_latitude();
  inline void set_has_altitude();
  inline void clear_has_altitude();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 longitude_;
  ::google::protobuf::int32 latitude_;
  ::google::protobuf::RepeatedField< float > velocity_;
  ::google::protobuf::int32 altitude_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static GpsInformation* default_instance_;
};
// -------------------------------------------------------------------

class OperationStatus : public ::google::protobuf::Message {
 public:
  OperationStatus();
  virtual ~OperationStatus();

  OperationStatus(const OperationStatus& from);

  inline OperationStatus& operator=(const OperationStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OperationStatus& default_instance();

  void Swap(OperationStatus* other);

  // implements Message ----------------------------------------------

  OperationStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OperationStatus& from);
  void MergeFrom(const OperationStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string operationmode = 1;
  inline bool has_operationmode() const;
  inline void clear_operationmode();
  static const int kOperationmodeFieldNumber = 1;
  inline const ::std::string& operationmode() const;
  inline void set_operationmode(const ::std::string& value);
  inline void set_operationmode(const char* value);
  inline void set_operationmode(const char* value, size_t size);
  inline ::std::string* mutable_operationmode();
  inline ::std::string* release_operationmode();
  inline void set_allocated_operationmode(::std::string* operationmode);

  // optional float voltage = 2;
  inline bool has_voltage() const;
  inline void clear_voltage();
  static const int kVoltageFieldNumber = 2;
  inline float voltage() const;
  inline void set_voltage(float value);

  // optional float surplusenergy = 3;
  inline bool has_surplusenergy() const;
  inline void clear_surplusenergy();
  static const int kSurplusenergyFieldNumber = 3;
  inline float surplusenergy() const;
  inline void set_surplusenergy(float value);

  // optional float jetvelocity = 4;
  inline bool has_jetvelocity() const;
  inline void clear_jetvelocity();
  static const int kJetvelocityFieldNumber = 4;
  inline float jetvelocity() const;
  inline void set_jetvelocity(float value);

  // optional float sprayeddose = 5;
  inline bool has_sprayeddose() const;
  inline void clear_sprayeddose();
  static const int kSprayeddoseFieldNumber = 5;
  inline float sprayeddose() const;
  inline void set_sprayeddose(float value);

  // @@protoc_insertion_point(class_scope:das.proto.OperationStatus)
 private:
  inline void set_has_operationmode();
  inline void clear_has_operationmode();
  inline void set_has_voltage();
  inline void clear_has_voltage();
  inline void set_has_surplusenergy();
  inline void clear_has_surplusenergy();
  inline void set_has_jetvelocity();
  inline void clear_has_jetvelocity();
  inline void set_has_sprayeddose();
  inline void clear_has_sprayeddose();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* operationmode_;
  float voltage_;
  float surplusenergy_;
  float jetvelocity_;
  float sprayeddose_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static OperationStatus* default_instance_;
};
// -------------------------------------------------------------------

class OperationParams : public ::google::protobuf::Message {
 public:
  OperationParams();
  virtual ~OperationParams();

  OperationParams(const OperationParams& from);

  inline OperationParams& operator=(const OperationParams& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OperationParams& default_instance();

  void Swap(OperationParams* other);

  // implements Message ----------------------------------------------

  OperationParams* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OperationParams& from);
  void MergeFrom(const OperationParams& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float alarmvoltage = 1;
  inline bool has_alarmvoltage() const;
  inline void clear_alarmvoltage();
  static const int kAlarmvoltageFieldNumber = 1;
  inline float alarmvoltage() const;
  inline void set_alarmvoltage(float value);

  // optional float alarmdose = 2;
  inline bool has_alarmdose() const;
  inline void clear_alarmdose();
  static const int kAlarmdoseFieldNumber = 2;
  inline float alarmdose() const;
  inline void set_alarmdose(float value);

  // optional float sprayingwidth = 3;
  inline bool has_sprayingwidth() const;
  inline void clear_sprayingwidth();
  static const int kSprayingwidthFieldNumber = 3;
  inline float sprayingwidth() const;
  inline void set_sprayingwidth(float value);

  // optional float desiredaltitude = 4;
  inline bool has_desiredaltitude() const;
  inline void clear_desiredaltitude();
  static const int kDesiredaltitudeFieldNumber = 4;
  inline float desiredaltitude() const;
  inline void set_desiredaltitude(float value);

  // optional float desiredvelocity = 5;
  inline bool has_desiredvelocity() const;
  inline void clear_desiredvelocity();
  static const int kDesiredvelocityFieldNumber = 5;
  inline float desiredvelocity() const;
  inline void set_desiredvelocity(float value);

  // optional float jetvelocity = 6;
  inline bool has_jetvelocity() const;
  inline void clear_jetvelocity();
  static const int kJetvelocityFieldNumber = 6;
  inline float jetvelocity() const;
  inline void set_jetvelocity(float value);

  // @@protoc_insertion_point(class_scope:das.proto.OperationParams)
 private:
  inline void set_has_alarmvoltage();
  inline void clear_has_alarmvoltage();
  inline void set_has_alarmdose();
  inline void clear_has_alarmdose();
  inline void set_has_sprayingwidth();
  inline void clear_has_sprayingwidth();
  inline void set_has_desiredaltitude();
  inline void clear_has_desiredaltitude();
  inline void set_has_desiredvelocity();
  inline void clear_has_desiredvelocity();
  inline void set_has_jetvelocity();
  inline void clear_has_jetvelocity();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float alarmvoltage_;
  float alarmdose_;
  float sprayingwidth_;
  float desiredaltitude_;
  float desiredvelocity_;
  float jetvelocity_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static OperationParams* default_instance_;
};
// -------------------------------------------------------------------

class OperationInformation : public ::google::protobuf::Message {
 public:
  OperationInformation();
  virtual ~OperationInformation();

  OperationInformation(const OperationInformation& from);

  inline OperationInformation& operator=(const OperationInformation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OperationInformation& default_instance();

  void Swap(OperationInformation* other);

  // implements Message ----------------------------------------------

  OperationInformation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OperationInformation& from);
  void MergeFrom(const OperationInformation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string uavid = 1;
  inline bool has_uavid() const;
  inline void clear_uavid();
  static const int kUavidFieldNumber = 1;
  inline const ::std::string& uavid() const;
  inline void set_uavid(const ::std::string& value);
  inline void set_uavid(const char* value);
  inline void set_uavid(const char* value, size_t size);
  inline ::std::string* mutable_uavid();
  inline ::std::string* release_uavid();
  inline void set_allocated_uavid(::std::string* uavid);

  // required uint64 timestamp = 2;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  inline ::google::protobuf::uint64 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint64 value);

  // required .das.proto.GpsInformation gps = 3;
  inline bool has_gps() const;
  inline void clear_gps();
  static const int kGpsFieldNumber = 3;
  inline const ::das::proto::GpsInformation& gps() const;
  inline ::das::proto::GpsInformation* mutable_gps();
  inline ::das::proto::GpsInformation* release_gps();
  inline void set_allocated_gps(::das::proto::GpsInformation* gps);

  // optional .das.proto.OperationStatus status = 4;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 4;
  inline const ::das::proto::OperationStatus& status() const;
  inline ::das::proto::OperationStatus* mutable_status();
  inline ::das::proto::OperationStatus* release_status();
  inline void set_allocated_status(::das::proto::OperationStatus* status);

  // optional .das.proto.OperationParams params = 5;
  inline bool has_params() const;
  inline void clear_params();
  static const int kParamsFieldNumber = 5;
  inline const ::das::proto::OperationParams& params() const;
  inline ::das::proto::OperationParams* mutable_params();
  inline ::das::proto::OperationParams* release_params();
  inline void set_allocated_params(::das::proto::OperationParams* params);

  // @@protoc_insertion_point(class_scope:das.proto.OperationInformation)
 private:
  inline void set_has_uavid();
  inline void clear_has_uavid();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_gps();
  inline void clear_has_gps();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_params();
  inline void clear_has_params();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uavid_;
  ::google::protobuf::uint64 timestamp_;
  ::das::proto::GpsInformation* gps_;
  ::das::proto::OperationStatus* status_;
  ::das::proto::OperationParams* params_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static OperationInformation* default_instance_;
};
// -------------------------------------------------------------------

class PostOperationInformation : public ::google::protobuf::Message {
 public:
  PostOperationInformation();
  virtual ~PostOperationInformation();

  PostOperationInformation(const PostOperationInformation& from);

  inline PostOperationInformation& operator=(const PostOperationInformation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PostOperationInformation& default_instance();

  void Swap(PostOperationInformation* other);

  // implements Message ----------------------------------------------

  PostOperationInformation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PostOperationInformation& from);
  void MergeFrom(const PostOperationInformation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // repeated .das.proto.OperationInformation oi = 2;
  inline int oi_size() const;
  inline void clear_oi();
  static const int kOiFieldNumber = 2;
  inline const ::das::proto::OperationInformation& oi(int index) const;
  inline ::das::proto::OperationInformation* mutable_oi(int index);
  inline ::das::proto::OperationInformation* add_oi();
  inline const ::google::protobuf::RepeatedPtrField< ::das::proto::OperationInformation >&
      oi() const;
  inline ::google::protobuf::RepeatedPtrField< ::das::proto::OperationInformation >*
      mutable_oi();

  // @@protoc_insertion_point(class_scope:das.proto.PostOperationInformation)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::das::proto::OperationInformation > oi_;
  ::google::protobuf::uint32 seqno_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static PostOperationInformation* default_instance_;
};
// -------------------------------------------------------------------

class AckOperationInformation : public ::google::protobuf::Message {
 public:
  AckOperationInformation();
  virtual ~AckOperationInformation();

  AckOperationInformation(const AckOperationInformation& from);

  inline AckOperationInformation& operator=(const AckOperationInformation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckOperationInformation& default_instance();

  void Swap(AckOperationInformation* other);

  // implements Message ----------------------------------------------

  AckOperationInformation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckOperationInformation& from);
  void MergeFrom(const AckOperationInformation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:das.proto.AckOperationInformation)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 seqno_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static AckOperationInformation* default_instance_;
};
// -------------------------------------------------------------------

class RequestIdentityAllocation : public ::google::protobuf::Message {
 public:
  RequestIdentityAllocation();
  virtual ~RequestIdentityAllocation();

  RequestIdentityAllocation(const RequestIdentityAllocation& from);

  inline RequestIdentityAllocation& operator=(const RequestIdentityAllocation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestIdentityAllocation& default_instance();

  void Swap(RequestIdentityAllocation* other);

  // implements Message ----------------------------------------------

  RequestIdentityAllocation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestIdentityAllocation& from);
  void MergeFrom(const RequestIdentityAllocation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required string devtype = 2;
  inline bool has_devtype() const;
  inline void clear_devtype();
  static const int kDevtypeFieldNumber = 2;
  inline const ::std::string& devtype() const;
  inline void set_devtype(const ::std::string& value);
  inline void set_devtype(const char* value);
  inline void set_devtype(const char* value, size_t size);
  inline ::std::string* mutable_devtype();
  inline ::std::string* release_devtype();
  inline void set_allocated_devtype(::std::string* devtype);

  // optional string extradata = 3;
  inline bool has_extradata() const;
  inline void clear_extradata();
  static const int kExtradataFieldNumber = 3;
  inline const ::std::string& extradata() const;
  inline void set_extradata(const ::std::string& value);
  inline void set_extradata(const char* value);
  inline void set_extradata(const char* value, size_t size);
  inline ::std::string* mutable_extradata();
  inline ::std::string* release_extradata();
  inline void set_allocated_extradata(::std::string* extradata);

  // @@protoc_insertion_point(class_scope:das.proto.RequestIdentityAllocation)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_devtype();
  inline void clear_has_devtype();
  inline void set_has_extradata();
  inline void clear_has_extradata();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* devtype_;
  ::std::string* extradata_;
  ::google::protobuf::uint32 seqno_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static RequestIdentityAllocation* default_instance_;
};
// -------------------------------------------------------------------

class AckIdentityAllocation : public ::google::protobuf::Message {
 public:
  AckIdentityAllocation();
  virtual ~AckIdentityAllocation();

  AckIdentityAllocation(const AckIdentityAllocation& from);

  inline AckIdentityAllocation& operator=(const AckIdentityAllocation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckIdentityAllocation& default_instance();

  void Swap(AckIdentityAllocation* other);

  // implements Message ----------------------------------------------

  AckIdentityAllocation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckIdentityAllocation& from);
  void MergeFrom(const AckIdentityAllocation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional string id = 3;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 3;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional string extradata = 4;
  inline bool has_extradata() const;
  inline void clear_extradata();
  static const int kExtradataFieldNumber = 4;
  inline const ::std::string& extradata() const;
  inline void set_extradata(const ::std::string& value);
  inline void set_extradata(const char* value);
  inline void set_extradata(const char* value, size_t size);
  inline ::std::string* mutable_extradata();
  inline ::std::string* release_extradata();
  inline void set_allocated_extradata(::std::string* extradata);

  // @@protoc_insertion_point(class_scope:das.proto.AckIdentityAllocation)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_extradata();
  inline void clear_has_extradata();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 seqno_;
  ::google::protobuf::int32 result_;
  ::std::string* id_;
  ::std::string* extradata_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static AckIdentityAllocation* default_instance_;
};
// -------------------------------------------------------------------

class PostHeartBeat : public ::google::protobuf::Message {
 public:
  PostHeartBeat();
  virtual ~PostHeartBeat();

  PostHeartBeat(const PostHeartBeat& from);

  inline PostHeartBeat& operator=(const PostHeartBeat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PostHeartBeat& default_instance();

  void Swap(PostHeartBeat* other);

  // implements Message ----------------------------------------------

  PostHeartBeat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PostHeartBeat& from);
  void MergeFrom(const PostHeartBeat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // optional string id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // @@protoc_insertion_point(class_scope:das.proto.PostHeartBeat)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::google::protobuf::uint32 seqno_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static PostHeartBeat* default_instance_;
};
// -------------------------------------------------------------------

class AckHeartBeat : public ::google::protobuf::Message {
 public:
  AckHeartBeat();
  virtual ~AckHeartBeat();

  AckHeartBeat(const AckHeartBeat& from);

  inline AckHeartBeat& operator=(const AckHeartBeat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckHeartBeat& default_instance();

  void Swap(AckHeartBeat* other);

  // implements Message ----------------------------------------------

  AckHeartBeat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckHeartBeat& from);
  void MergeFrom(const AckHeartBeat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:das.proto.AckHeartBeat)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 seqno_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static AckHeartBeat* default_instance_;
};
// -------------------------------------------------------------------

class RequestProgramUpgrade : public ::google::protobuf::Message {
 public:
  RequestProgramUpgrade();
  virtual ~RequestProgramUpgrade();

  RequestProgramUpgrade(const RequestProgramUpgrade& from);

  inline RequestProgramUpgrade& operator=(const RequestProgramUpgrade& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestProgramUpgrade& default_instance();

  void Swap(RequestProgramUpgrade* other);

  // implements Message ----------------------------------------------

  RequestProgramUpgrade* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestProgramUpgrade& from);
  void MergeFrom(const RequestProgramUpgrade& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required string hardware = 2;
  inline bool has_hardware() const;
  inline void clear_hardware();
  static const int kHardwareFieldNumber = 2;
  inline const ::std::string& hardware() const;
  inline void set_hardware(const ::std::string& value);
  inline void set_hardware(const char* value);
  inline void set_hardware(const char* value, size_t size);
  inline ::std::string* mutable_hardware();
  inline ::std::string* release_hardware();
  inline void set_allocated_hardware(::std::string* hardware);

  // required string software = 3;
  inline bool has_software() const;
  inline void clear_software();
  static const int kSoftwareFieldNumber = 3;
  inline const ::std::string& software() const;
  inline void set_software(const ::std::string& value);
  inline void set_software(const char* value);
  inline void set_software(const char* value, size_t size);
  inline ::std::string* mutable_software();
  inline ::std::string* release_software();
  inline void set_allocated_software(::std::string* software);

  // optional string extradata = 4;
  inline bool has_extradata() const;
  inline void clear_extradata();
  static const int kExtradataFieldNumber = 4;
  inline const ::std::string& extradata() const;
  inline void set_extradata(const ::std::string& value);
  inline void set_extradata(const char* value);
  inline void set_extradata(const char* value, size_t size);
  inline ::std::string* mutable_extradata();
  inline ::std::string* release_extradata();
  inline void set_allocated_extradata(::std::string* extradata);

  // @@protoc_insertion_point(class_scope:das.proto.RequestProgramUpgrade)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_hardware();
  inline void clear_has_hardware();
  inline void set_has_software();
  inline void clear_has_software();
  inline void set_has_extradata();
  inline void clear_has_extradata();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* hardware_;
  ::std::string* software_;
  ::std::string* extradata_;
  ::google::protobuf::uint32 seqno_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static RequestProgramUpgrade* default_instance_;
};
// -------------------------------------------------------------------

class AckProgramUpgrade : public ::google::protobuf::Message {
 public:
  AckProgramUpgrade();
  virtual ~AckProgramUpgrade();

  AckProgramUpgrade(const AckProgramUpgrade& from);

  inline AckProgramUpgrade& operator=(const AckProgramUpgrade& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckProgramUpgrade& default_instance();

  void Swap(AckProgramUpgrade* other);

  // implements Message ----------------------------------------------

  AckProgramUpgrade* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckProgramUpgrade& from);
  void MergeFrom(const AckProgramUpgrade& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // required string software = 3;
  inline bool has_software() const;
  inline void clear_software();
  static const int kSoftwareFieldNumber = 3;
  inline const ::std::string& software() const;
  inline void set_software(const ::std::string& value);
  inline void set_software(const char* value);
  inline void set_software(const char* value, size_t size);
  inline ::std::string* mutable_software();
  inline ::std::string* release_software();
  inline void set_allocated_software(::std::string* software);

  // required int32 length = 4;
  inline bool has_length() const;
  inline void clear_length();
  static const int kLengthFieldNumber = 4;
  inline ::google::protobuf::int32 length() const;
  inline void set_length(::google::protobuf::int32 value);

  // required bool forced = 5;
  inline bool has_forced() const;
  inline void clear_forced();
  static const int kForcedFieldNumber = 5;
  inline bool forced() const;
  inline void set_forced(bool value);

  // optional string extradata = 6;
  inline bool has_extradata() const;
  inline void clear_extradata();
  static const int kExtradataFieldNumber = 6;
  inline const ::std::string& extradata() const;
  inline void set_extradata(const ::std::string& value);
  inline void set_extradata(const char* value);
  inline void set_extradata(const char* value, size_t size);
  inline ::std::string* mutable_extradata();
  inline ::std::string* release_extradata();
  inline void set_allocated_extradata(::std::string* extradata);

  // @@protoc_insertion_point(class_scope:das.proto.AckProgramUpgrade)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_software();
  inline void clear_has_software();
  inline void set_has_length();
  inline void clear_has_length();
  inline void set_has_forced();
  inline void clear_has_forced();
  inline void set_has_extradata();
  inline void clear_has_extradata();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 seqno_;
  ::google::protobuf::int32 result_;
  ::std::string* software_;
  ::google::protobuf::int32 length_;
  bool forced_;
  ::std::string* extradata_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static AckProgramUpgrade* default_instance_;
};
// -------------------------------------------------------------------

class RequestProgramDownload : public ::google::protobuf::Message {
 public:
  RequestProgramDownload();
  virtual ~RequestProgramDownload();

  RequestProgramDownload(const RequestProgramDownload& from);

  inline RequestProgramDownload& operator=(const RequestProgramDownload& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestProgramDownload& default_instance();

  void Swap(RequestProgramDownload* other);

  // implements Message ----------------------------------------------

  RequestProgramDownload* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestProgramDownload& from);
  void MergeFrom(const RequestProgramDownload& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required string software = 2;
  inline bool has_software() const;
  inline void clear_software();
  static const int kSoftwareFieldNumber = 2;
  inline const ::std::string& software() const;
  inline void set_software(const ::std::string& value);
  inline void set_software(const char* value);
  inline void set_software(const char* value, size_t size);
  inline ::std::string* mutable_software();
  inline ::std::string* release_software();
  inline void set_allocated_software(::std::string* software);

  // required int32 offset = 3;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 3;
  inline ::google::protobuf::int32 offset() const;
  inline void set_offset(::google::protobuf::int32 value);

  // required int32 length = 4;
  inline bool has_length() const;
  inline void clear_length();
  static const int kLengthFieldNumber = 4;
  inline ::google::protobuf::int32 length() const;
  inline void set_length(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:das.proto.RequestProgramDownload)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_software();
  inline void clear_has_software();
  inline void set_has_offset();
  inline void clear_has_offset();
  inline void set_has_length();
  inline void clear_has_length();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* software_;
  ::google::protobuf::uint32 seqno_;
  ::google::protobuf::int32 offset_;
  ::google::protobuf::int32 length_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static RequestProgramDownload* default_instance_;
};
// -------------------------------------------------------------------

class AckProgramDownload : public ::google::protobuf::Message {
 public:
  AckProgramDownload();
  virtual ~AckProgramDownload();

  AckProgramDownload(const AckProgramDownload& from);

  inline AckProgramDownload& operator=(const AckProgramDownload& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckProgramDownload& default_instance();

  void Swap(AckProgramDownload* other);

  // implements Message ----------------------------------------------

  AckProgramDownload* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckProgramDownload& from);
  void MergeFrom(const AckProgramDownload& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // required string software = 3;
  inline bool has_software() const;
  inline void clear_software();
  static const int kSoftwareFieldNumber = 3;
  inline const ::std::string& software() const;
  inline void set_software(const ::std::string& value);
  inline void set_software(const char* value);
  inline void set_software(const char* value, size_t size);
  inline ::std::string* mutable_software();
  inline ::std::string* release_software();
  inline void set_allocated_software(::std::string* software);

  // required int32 offset = 4;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 4;
  inline ::google::protobuf::int32 offset() const;
  inline void set_offset(::google::protobuf::int32 value);

  // required int32 length = 5;
  inline bool has_length() const;
  inline void clear_length();
  static const int kLengthFieldNumber = 5;
  inline ::google::protobuf::int32 length() const;
  inline void set_length(::google::protobuf::int32 value);

  // optional bytes data = 6;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 6;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // optional uint32 crc32 = 7;
  inline bool has_crc32() const;
  inline void clear_crc32();
  static const int kCrc32FieldNumber = 7;
  inline ::google::protobuf::uint32 crc32() const;
  inline void set_crc32(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:das.proto.AckProgramDownload)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_software();
  inline void clear_has_software();
  inline void set_has_offset();
  inline void clear_has_offset();
  inline void set_has_length();
  inline void clear_has_length();
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_crc32();
  inline void clear_has_crc32();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 seqno_;
  ::google::protobuf::int32 result_;
  ::std::string* software_;
  ::google::protobuf::int32 offset_;
  ::google::protobuf::int32 length_;
  ::std::string* data_;
  ::google::protobuf::uint32 crc32_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static AckProgramDownload* default_instance_;
};
// -------------------------------------------------------------------

class ParameterDescription : public ::google::protobuf::Message {
 public:
  ParameterDescription();
  virtual ~ParameterDescription();

  ParameterDescription(const ParameterDescription& from);

  inline ParameterDescription& operator=(const ParameterDescription& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ParameterDescription& default_instance();

  void Swap(ParameterDescription* other);

  // implements Message ----------------------------------------------

  ParameterDescription* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ParameterDescription& from);
  void MergeFrom(const ParameterDescription& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required bool readonly = 2;
  inline bool has_readonly() const;
  inline void clear_readonly();
  static const int kReadonlyFieldNumber = 2;
  inline bool readonly() const;
  inline void set_readonly(bool value);

  // required uint32 type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // required string value = 4;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 4;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:das.proto.ParameterDescription)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_readonly();
  inline void clear_has_readonly();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  bool readonly_;
  ::google::protobuf::uint32 type_;
  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static ParameterDescription* default_instance_;
};
// -------------------------------------------------------------------

class QueryParameters : public ::google::protobuf::Message {
 public:
  QueryParameters();
  virtual ~QueryParameters();

  QueryParameters(const QueryParameters& from);

  inline QueryParameters& operator=(const QueryParameters& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QueryParameters& default_instance();

  void Swap(QueryParameters* other);

  // implements Message ----------------------------------------------

  QueryParameters* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QueryParameters& from);
  void MergeFrom(const QueryParameters& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required string id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // @@protoc_insertion_point(class_scope:das.proto.QueryParameters)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::google::protobuf::uint32 seqno_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static QueryParameters* default_instance_;
};
// -------------------------------------------------------------------

class AckQueryParameters : public ::google::protobuf::Message {
 public:
  AckQueryParameters();
  virtual ~AckQueryParameters();

  AckQueryParameters(const AckQueryParameters& from);

  inline AckQueryParameters& operator=(const AckQueryParameters& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckQueryParameters& default_instance();

  void Swap(AckQueryParameters* other);

  // implements Message ----------------------------------------------

  AckQueryParameters* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckQueryParameters& from);
  void MergeFrom(const AckQueryParameters& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required string id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required int32 result = 3;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 3;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // repeated .das.proto.ParameterDescription pd = 4;
  inline int pd_size() const;
  inline void clear_pd();
  static const int kPdFieldNumber = 4;
  inline const ::das::proto::ParameterDescription& pd(int index) const;
  inline ::das::proto::ParameterDescription* mutable_pd(int index);
  inline ::das::proto::ParameterDescription* add_pd();
  inline const ::google::protobuf::RepeatedPtrField< ::das::proto::ParameterDescription >&
      pd() const;
  inline ::google::protobuf::RepeatedPtrField< ::das::proto::ParameterDescription >*
      mutable_pd();

  // @@protoc_insertion_point(class_scope:das.proto.AckQueryParameters)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::google::protobuf::uint32 seqno_;
  ::google::protobuf::int32 result_;
  ::google::protobuf::RepeatedPtrField< ::das::proto::ParameterDescription > pd_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static AckQueryParameters* default_instance_;
};
// -------------------------------------------------------------------

class ConfigureParameters : public ::google::protobuf::Message {
 public:
  ConfigureParameters();
  virtual ~ConfigureParameters();

  ConfigureParameters(const ConfigureParameters& from);

  inline ConfigureParameters& operator=(const ConfigureParameters& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConfigureParameters& default_instance();

  void Swap(ConfigureParameters* other);

  // implements Message ----------------------------------------------

  ConfigureParameters* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConfigureParameters& from);
  void MergeFrom(const ConfigureParameters& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required string id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // repeated .das.proto.ParameterDescription pd = 3;
  inline int pd_size() const;
  inline void clear_pd();
  static const int kPdFieldNumber = 3;
  inline const ::das::proto::ParameterDescription& pd(int index) const;
  inline ::das::proto::ParameterDescription* mutable_pd(int index);
  inline ::das::proto::ParameterDescription* add_pd();
  inline const ::google::protobuf::RepeatedPtrField< ::das::proto::ParameterDescription >&
      pd() const;
  inline ::google::protobuf::RepeatedPtrField< ::das::proto::ParameterDescription >*
      mutable_pd();

  // @@protoc_insertion_point(class_scope:das.proto.ConfigureParameters)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::google::protobuf::RepeatedPtrField< ::das::proto::ParameterDescription > pd_;
  ::google::protobuf::uint32 seqno_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static ConfigureParameters* default_instance_;
};
// -------------------------------------------------------------------

class AckConfigurParameters : public ::google::protobuf::Message {
 public:
  AckConfigurParameters();
  virtual ~AckConfigurParameters();

  AckConfigurParameters(const AckConfigurParameters& from);

  inline AckConfigurParameters& operator=(const AckConfigurParameters& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckConfigurParameters& default_instance();

  void Swap(AckConfigurParameters* other);

  // implements Message ----------------------------------------------

  AckConfigurParameters* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckConfigurParameters& from);
  void MergeFrom(const AckConfigurParameters& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required string id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required int32 result = 3;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 3;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:das.proto.AckConfigurParameters)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::google::protobuf::uint32 seqno_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static AckConfigurParameters* default_instance_;
};
// -------------------------------------------------------------------

class Coordinate : public ::google::protobuf::Message {
 public:
  Coordinate();
  virtual ~Coordinate();

  Coordinate(const Coordinate& from);

  inline Coordinate& operator=(const Coordinate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Coordinate& default_instance();

  void Swap(Coordinate* other);

  // implements Message ----------------------------------------------

  Coordinate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Coordinate& from);
  void MergeFrom(const Coordinate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 longitude = 1;
  inline bool has_longitude() const;
  inline void clear_longitude();
  static const int kLongitudeFieldNumber = 1;
  inline ::google::protobuf::int32 longitude() const;
  inline void set_longitude(::google::protobuf::int32 value);

  // required int32 latitude = 2;
  inline bool has_latitude() const;
  inline void clear_latitude();
  static const int kLatitudeFieldNumber = 2;
  inline ::google::protobuf::int32 latitude() const;
  inline void set_latitude(::google::protobuf::int32 value);

  // optional int32 altitude = 3;
  inline bool has_altitude() const;
  inline void clear_altitude();
  static const int kAltitudeFieldNumber = 3;
  inline ::google::protobuf::int32 altitude() const;
  inline void set_altitude(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:das.proto.Coordinate)
 private:
  inline void set_has_longitude();
  inline void clear_has_longitude();
  inline void set_has_latitude();
  inline void clear_has_latitude();
  inline void set_has_altitude();
  inline void clear_has_altitude();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 longitude_;
  ::google::protobuf::int32 latitude_;
  ::google::protobuf::int32 altitude_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static Coordinate* default_instance_;
};
// -------------------------------------------------------------------

class OperationSnapshot : public ::google::protobuf::Message {
 public:
  OperationSnapshot();
  virtual ~OperationSnapshot();

  OperationSnapshot(const OperationSnapshot& from);

  inline OperationSnapshot& operator=(const OperationSnapshot& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OperationSnapshot& default_instance();

  void Swap(OperationSnapshot* other);

  // implements Message ----------------------------------------------

  OperationSnapshot* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OperationSnapshot& from);
  void MergeFrom(const OperationSnapshot& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string devid = 1;
  inline bool has_devid() const;
  inline void clear_devid();
  static const int kDevidFieldNumber = 1;
  inline const ::std::string& devid() const;
  inline void set_devid(const ::std::string& value);
  inline void set_devid(const char* value);
  inline void set_devid(const char* value, size_t size);
  inline ::std::string* mutable_devid();
  inline ::std::string* release_devid();
  inline void set_allocated_devid(::std::string* devid);

  // required uint64 timestamp = 2;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  inline ::google::protobuf::uint64 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint64 value);

  // optional .das.proto.Coordinate pos = 3;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 3;
  inline const ::das::proto::Coordinate& pos() const;
  inline ::das::proto::Coordinate* mutable_pos();
  inline ::das::proto::Coordinate* release_pos();
  inline void set_allocated_pos(::das::proto::Coordinate* pos);

  // optional int32 size = 4;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 4;
  inline ::google::protobuf::int32 size() const;
  inline void set_size(::google::protobuf::int32 value);

  // required bytes pic = 5;
  inline bool has_pic() const;
  inline void clear_pic();
  static const int kPicFieldNumber = 5;
  inline const ::std::string& pic() const;
  inline void set_pic(const ::std::string& value);
  inline void set_pic(const char* value);
  inline void set_pic(const void* value, size_t size);
  inline ::std::string* mutable_pic();
  inline ::std::string* release_pic();
  inline void set_allocated_pic(::std::string* pic);

  // @@protoc_insertion_point(class_scope:das.proto.OperationSnapshot)
 private:
  inline void set_has_devid();
  inline void clear_has_devid();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_pos();
  inline void clear_has_pos();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_pic();
  inline void clear_has_pic();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* devid_;
  ::google::protobuf::uint64 timestamp_;
  ::das::proto::Coordinate* pos_;
  ::std::string* pic_;
  ::google::protobuf::int32 size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static OperationSnapshot* default_instance_;
};
// -------------------------------------------------------------------

class PostOperationSnapshot : public ::google::protobuf::Message {
 public:
  PostOperationSnapshot();
  virtual ~PostOperationSnapshot();

  PostOperationSnapshot(const PostOperationSnapshot& from);

  inline PostOperationSnapshot& operator=(const PostOperationSnapshot& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PostOperationSnapshot& default_instance();

  void Swap(PostOperationSnapshot* other);

  // implements Message ----------------------------------------------

  PostOperationSnapshot* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PostOperationSnapshot& from);
  void MergeFrom(const PostOperationSnapshot& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required .das.proto.OperationSnapshot os = 2;
  inline bool has_os() const;
  inline void clear_os();
  static const int kOsFieldNumber = 2;
  inline const ::das::proto::OperationSnapshot& os() const;
  inline ::das::proto::OperationSnapshot* mutable_os();
  inline ::das::proto::OperationSnapshot* release_os();
  inline void set_allocated_os(::das::proto::OperationSnapshot* os);

  // @@protoc_insertion_point(class_scope:das.proto.PostOperationSnapshot)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_os();
  inline void clear_has_os();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::das::proto::OperationSnapshot* os_;
  ::google::protobuf::uint32 seqno_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static PostOperationSnapshot* default_instance_;
};
// -------------------------------------------------------------------

class AckPostOperationSnapshot : public ::google::protobuf::Message {
 public:
  AckPostOperationSnapshot();
  virtual ~AckPostOperationSnapshot();

  AckPostOperationSnapshot(const AckPostOperationSnapshot& from);

  inline AckPostOperationSnapshot& operator=(const AckPostOperationSnapshot& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckPostOperationSnapshot& default_instance();

  void Swap(AckPostOperationSnapshot* other);

  // implements Message ----------------------------------------------

  AckPostOperationSnapshot* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckPostOperationSnapshot& from);
  void MergeFrom(const AckPostOperationSnapshot& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:das.proto.AckPostOperationSnapshot)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 seqno_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static AckPostOperationSnapshot* default_instance_;
};
// -------------------------------------------------------------------

class RequestPositionAuthentication : public ::google::protobuf::Message {
 public:
  RequestPositionAuthentication();
  virtual ~RequestPositionAuthentication();

  RequestPositionAuthentication(const RequestPositionAuthentication& from);

  inline RequestPositionAuthentication& operator=(const RequestPositionAuthentication& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestPositionAuthentication& default_instance();

  void Swap(RequestPositionAuthentication* other);

  // implements Message ----------------------------------------------

  RequestPositionAuthentication* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestPositionAuthentication& from);
  void MergeFrom(const RequestPositionAuthentication& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required string devid = 2;
  inline bool has_devid() const;
  inline void clear_devid();
  static const int kDevidFieldNumber = 2;
  inline const ::std::string& devid() const;
  inline void set_devid(const ::std::string& value);
  inline void set_devid(const char* value);
  inline void set_devid(const char* value, size_t size);
  inline ::std::string* mutable_devid();
  inline ::std::string* release_devid();
  inline void set_allocated_devid(::std::string* devid);

  // required .das.proto.GpsInformation pos = 3;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 3;
  inline const ::das::proto::GpsInformation& pos() const;
  inline ::das::proto::GpsInformation* mutable_pos();
  inline ::das::proto::GpsInformation* release_pos();
  inline void set_allocated_pos(::das::proto::GpsInformation* pos);

  // @@protoc_insertion_point(class_scope:das.proto.RequestPositionAuthentication)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_devid();
  inline void clear_has_devid();
  inline void set_has_pos();
  inline void clear_has_pos();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* devid_;
  ::das::proto::GpsInformation* pos_;
  ::google::protobuf::uint32 seqno_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static RequestPositionAuthentication* default_instance_;
};
// -------------------------------------------------------------------

class AckPositionAuthentication : public ::google::protobuf::Message {
 public:
  AckPositionAuthentication();
  virtual ~AckPositionAuthentication();

  AckPositionAuthentication(const AckPositionAuthentication& from);

  inline AckPositionAuthentication& operator=(const AckPositionAuthentication& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckPositionAuthentication& default_instance();

  void Swap(AckPositionAuthentication* other);

  // implements Message ----------------------------------------------

  AckPositionAuthentication* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckPositionAuthentication& from);
  void MergeFrom(const AckPositionAuthentication& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:das.proto.AckPositionAuthentication)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 seqno_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static AckPositionAuthentication* default_instance_;
};
// -------------------------------------------------------------------

class ReportDeviceException : public ::google::protobuf::Message {
 public:
  ReportDeviceException();
  virtual ~ReportDeviceException();

  ReportDeviceException(const ReportDeviceException& from);

  inline ReportDeviceException& operator=(const ReportDeviceException& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReportDeviceException& default_instance();

  void Swap(ReportDeviceException* other);

  // implements Message ----------------------------------------------

  ReportDeviceException* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReportDeviceException& from);
  void MergeFrom(const ReportDeviceException& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required string id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // repeated string desc = 3;
  inline int desc_size() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 3;
  inline const ::std::string& desc(int index) const;
  inline ::std::string* mutable_desc(int index);
  inline void set_desc(int index, const ::std::string& value);
  inline void set_desc(int index, const char* value);
  inline void set_desc(int index, const char* value, size_t size);
  inline ::std::string* add_desc();
  inline void add_desc(const ::std::string& value);
  inline void add_desc(const char* value);
  inline void add_desc(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& desc() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_desc();

  // @@protoc_insertion_point(class_scope:das.proto.ReportDeviceException)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::google::protobuf::RepeatedPtrField< ::std::string> desc_;
  ::google::protobuf::uint32 seqno_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static ReportDeviceException* default_instance_;
};
// -------------------------------------------------------------------

class AckReportDeviceException : public ::google::protobuf::Message {
 public:
  AckReportDeviceException();
  virtual ~AckReportDeviceException();

  AckReportDeviceException(const AckReportDeviceException& from);

  inline AckReportDeviceException& operator=(const AckReportDeviceException& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckReportDeviceException& default_instance();

  void Swap(AckReportDeviceException* other);

  // implements Message ----------------------------------------------

  AckReportDeviceException* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckReportDeviceException& from);
  void MergeFrom(const AckReportDeviceException& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:das.proto.AckReportDeviceException)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 seqno_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static AckReportDeviceException* default_instance_;
};
// -------------------------------------------------------------------

class RequestGVIdentityAuthentication : public ::google::protobuf::Message {
 public:
  RequestGVIdentityAuthentication();
  virtual ~RequestGVIdentityAuthentication();

  RequestGVIdentityAuthentication(const RequestGVIdentityAuthentication& from);

  inline RequestGVIdentityAuthentication& operator=(const RequestGVIdentityAuthentication& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestGVIdentityAuthentication& default_instance();

  void Swap(RequestGVIdentityAuthentication* other);

  // implements Message ----------------------------------------------

  RequestGVIdentityAuthentication* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestGVIdentityAuthentication& from);
  void MergeFrom(const RequestGVIdentityAuthentication& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required string userid = 2;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUseridFieldNumber = 2;
  inline const ::std::string& userid() const;
  inline void set_userid(const ::std::string& value);
  inline void set_userid(const char* value);
  inline void set_userid(const char* value, size_t size);
  inline ::std::string* mutable_userid();
  inline ::std::string* release_userid();
  inline void set_allocated_userid(::std::string* userid);

  // required string password = 3;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 3;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional string extradata = 4;
  inline bool has_extradata() const;
  inline void clear_extradata();
  static const int kExtradataFieldNumber = 4;
  inline const ::std::string& extradata() const;
  inline void set_extradata(const ::std::string& value);
  inline void set_extradata(const char* value);
  inline void set_extradata(const char* value, size_t size);
  inline ::std::string* mutable_extradata();
  inline ::std::string* release_extradata();
  inline void set_allocated_extradata(::std::string* extradata);

  // @@protoc_insertion_point(class_scope:das.proto.RequestGVIdentityAuthentication)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_extradata();
  inline void clear_has_extradata();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* userid_;
  ::std::string* password_;
  ::std::string* extradata_;
  ::google::protobuf::uint32 seqno_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static RequestGVIdentityAuthentication* default_instance_;
};
// -------------------------------------------------------------------

class AckGVIdentityAuthentication : public ::google::protobuf::Message {
 public:
  AckGVIdentityAuthentication();
  virtual ~AckGVIdentityAuthentication();

  AckGVIdentityAuthentication(const AckGVIdentityAuthentication& from);

  inline AckGVIdentityAuthentication& operator=(const AckGVIdentityAuthentication& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckGVIdentityAuthentication& default_instance();

  void Swap(AckGVIdentityAuthentication* other);

  // implements Message ----------------------------------------------

  AckGVIdentityAuthentication* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckGVIdentityAuthentication& from);
  void MergeFrom(const AckGVIdentityAuthentication& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional string extradata = 3;
  inline bool has_extradata() const;
  inline void clear_extradata();
  static const int kExtradataFieldNumber = 3;
  inline const ::std::string& extradata() const;
  inline void set_extradata(const ::std::string& value);
  inline void set_extradata(const char* value);
  inline void set_extradata(const char* value, size_t size);
  inline ::std::string* mutable_extradata();
  inline ::std::string* release_extradata();
  inline void set_allocated_extradata(::std::string* extradata);

  // @@protoc_insertion_point(class_scope:das.proto.AckGVIdentityAuthentication)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_extradata();
  inline void clear_has_extradata();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 seqno_;
  ::google::protobuf::int32 result_;
  ::std::string* extradata_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static AckGVIdentityAuthentication* default_instance_;
};
// -------------------------------------------------------------------

class RequestIVIdentityAuthentication : public ::google::protobuf::Message {
 public:
  RequestIVIdentityAuthentication();
  virtual ~RequestIVIdentityAuthentication();

  RequestIVIdentityAuthentication(const RequestIVIdentityAuthentication& from);

  inline RequestIVIdentityAuthentication& operator=(const RequestIVIdentityAuthentication& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestIVIdentityAuthentication& default_instance();

  void Swap(RequestIVIdentityAuthentication* other);

  // implements Message ----------------------------------------------

  RequestIVIdentityAuthentication* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestIVIdentityAuthentication& from);
  void MergeFrom(const RequestIVIdentityAuthentication& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required string userid = 2;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUseridFieldNumber = 2;
  inline const ::std::string& userid() const;
  inline void set_userid(const ::std::string& value);
  inline void set_userid(const char* value);
  inline void set_userid(const char* value, size_t size);
  inline ::std::string* mutable_userid();
  inline ::std::string* release_userid();
  inline void set_allocated_userid(::std::string* userid);

  // required string password = 3;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 3;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional string extradata = 4;
  inline bool has_extradata() const;
  inline void clear_extradata();
  static const int kExtradataFieldNumber = 4;
  inline const ::std::string& extradata() const;
  inline void set_extradata(const ::std::string& value);
  inline void set_extradata(const char* value);
  inline void set_extradata(const char* value, size_t size);
  inline ::std::string* mutable_extradata();
  inline ::std::string* release_extradata();
  inline void set_allocated_extradata(::std::string* extradata);

  // @@protoc_insertion_point(class_scope:das.proto.RequestIVIdentityAuthentication)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_extradata();
  inline void clear_has_extradata();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* userid_;
  ::std::string* password_;
  ::std::string* extradata_;
  ::google::protobuf::uint32 seqno_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static RequestIVIdentityAuthentication* default_instance_;
};
// -------------------------------------------------------------------

class AckIVIdentityAuthentication : public ::google::protobuf::Message {
 public:
  AckIVIdentityAuthentication();
  virtual ~AckIVIdentityAuthentication();

  AckIVIdentityAuthentication(const AckIVIdentityAuthentication& from);

  inline AckIVIdentityAuthentication& operator=(const AckIVIdentityAuthentication& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckIVIdentityAuthentication& default_instance();

  void Swap(AckIVIdentityAuthentication* other);

  // implements Message ----------------------------------------------

  AckIVIdentityAuthentication* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckIVIdentityAuthentication& from);
  void MergeFrom(const AckIVIdentityAuthentication& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional string extradata = 3;
  inline bool has_extradata() const;
  inline void clear_extradata();
  static const int kExtradataFieldNumber = 3;
  inline const ::std::string& extradata() const;
  inline void set_extradata(const ::std::string& value);
  inline void set_extradata(const char* value);
  inline void set_extradata(const char* value, size_t size);
  inline ::std::string* mutable_extradata();
  inline ::std::string* release_extradata();
  inline void set_allocated_extradata(::std::string* extradata);

  // @@protoc_insertion_point(class_scope:das.proto.AckIVIdentityAuthentication)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_extradata();
  inline void clear_has_extradata();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 seqno_;
  ::google::protobuf::int32 result_;
  ::std::string* extradata_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static AckIVIdentityAuthentication* default_instance_;
};
// -------------------------------------------------------------------

class UpdateDeviceList : public ::google::protobuf::Message {
 public:
  UpdateDeviceList();
  virtual ~UpdateDeviceList();

  UpdateDeviceList(const UpdateDeviceList& from);

  inline UpdateDeviceList& operator=(const UpdateDeviceList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateDeviceList& default_instance();

  void Swap(UpdateDeviceList* other);

  // implements Message ----------------------------------------------

  UpdateDeviceList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateDeviceList& from);
  void MergeFrom(const UpdateDeviceList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required uint32 operation = 2;
  inline bool has_operation() const;
  inline void clear_operation();
  static const int kOperationFieldNumber = 2;
  inline ::google::protobuf::uint32 operation() const;
  inline void set_operation(::google::protobuf::uint32 value);

  // repeated string id = 3;
  inline int id_size() const;
  inline void clear_id();
  static const int kIdFieldNumber = 3;
  inline const ::std::string& id(int index) const;
  inline ::std::string* mutable_id(int index);
  inline void set_id(int index, const ::std::string& value);
  inline void set_id(int index, const char* value);
  inline void set_id(int index, const char* value, size_t size);
  inline ::std::string* add_id();
  inline void add_id(const ::std::string& value);
  inline void add_id(const char* value);
  inline void add_id(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& id() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_id();

  // @@protoc_insertion_point(class_scope:das.proto.UpdateDeviceList)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_operation();
  inline void clear_has_operation();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 seqno_;
  ::google::protobuf::uint32 operation_;
  ::google::protobuf::RepeatedPtrField< ::std::string> id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static UpdateDeviceList* default_instance_;
};
// -------------------------------------------------------------------

class AckUpdateDeviceList : public ::google::protobuf::Message {
 public:
  AckUpdateDeviceList();
  virtual ~AckUpdateDeviceList();

  AckUpdateDeviceList(const AckUpdateDeviceList& from);

  inline AckUpdateDeviceList& operator=(const AckUpdateDeviceList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckUpdateDeviceList& default_instance();

  void Swap(AckUpdateDeviceList* other);

  // implements Message ----------------------------------------------

  AckUpdateDeviceList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckUpdateDeviceList& from);
  void MergeFrom(const AckUpdateDeviceList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:das.proto.AckUpdateDeviceList)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 seqno_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static AckUpdateDeviceList* default_instance_;
};
// -------------------------------------------------------------------

class SyncDeviceList : public ::google::protobuf::Message {
 public:
  SyncDeviceList();
  virtual ~SyncDeviceList();

  SyncDeviceList(const SyncDeviceList& from);

  inline SyncDeviceList& operator=(const SyncDeviceList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SyncDeviceList& default_instance();

  void Swap(SyncDeviceList* other);

  // implements Message ----------------------------------------------

  SyncDeviceList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SyncDeviceList& from);
  void MergeFrom(const SyncDeviceList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:das.proto.SyncDeviceList)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 seqno_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static SyncDeviceList* default_instance_;
};
// -------------------------------------------------------------------

class AckSyncDeviceList : public ::google::protobuf::Message {
 public:
  AckSyncDeviceList();
  virtual ~AckSyncDeviceList();

  AckSyncDeviceList(const AckSyncDeviceList& from);

  inline AckSyncDeviceList& operator=(const AckSyncDeviceList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckSyncDeviceList& default_instance();

  void Swap(AckSyncDeviceList* other);

  // implements Message ----------------------------------------------

  AckSyncDeviceList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckSyncDeviceList& from);
  void MergeFrom(const AckSyncDeviceList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // repeated string id = 3;
  inline int id_size() const;
  inline void clear_id();
  static const int kIdFieldNumber = 3;
  inline const ::std::string& id(int index) const;
  inline ::std::string* mutable_id(int index);
  inline void set_id(int index, const ::std::string& value);
  inline void set_id(int index, const char* value);
  inline void set_id(int index, const char* value, size_t size);
  inline ::std::string* add_id();
  inline void add_id(const ::std::string& value);
  inline void add_id(const char* value);
  inline void add_id(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& id() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_id();

  // @@protoc_insertion_point(class_scope:das.proto.AckSyncDeviceList)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 seqno_;
  ::google::protobuf::int32 result_;
  ::google::protobuf::RepeatedPtrField< ::std::string> id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static AckSyncDeviceList* default_instance_;
};
// ===================================================================


// ===================================================================

// RequestTrackerIdentityAuthentication

// required uint32 seqno = 1;
inline bool RequestTrackerIdentityAuthentication::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestTrackerIdentityAuthentication::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestTrackerIdentityAuthentication::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestTrackerIdentityAuthentication::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 RequestTrackerIdentityAuthentication::seqno() const {
  return seqno_;
}
inline void RequestTrackerIdentityAuthentication::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required string trackerid = 2;
inline bool RequestTrackerIdentityAuthentication::has_trackerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestTrackerIdentityAuthentication::set_has_trackerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestTrackerIdentityAuthentication::clear_has_trackerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestTrackerIdentityAuthentication::clear_trackerid() {
  if (trackerid_ != &::google::protobuf::internal::kEmptyString) {
    trackerid_->clear();
  }
  clear_has_trackerid();
}
inline const ::std::string& RequestTrackerIdentityAuthentication::trackerid() const {
  return *trackerid_;
}
inline void RequestTrackerIdentityAuthentication::set_trackerid(const ::std::string& value) {
  set_has_trackerid();
  if (trackerid_ == &::google::protobuf::internal::kEmptyString) {
    trackerid_ = new ::std::string;
  }
  trackerid_->assign(value);
}
inline void RequestTrackerIdentityAuthentication::set_trackerid(const char* value) {
  set_has_trackerid();
  if (trackerid_ == &::google::protobuf::internal::kEmptyString) {
    trackerid_ = new ::std::string;
  }
  trackerid_->assign(value);
}
inline void RequestTrackerIdentityAuthentication::set_trackerid(const char* value, size_t size) {
  set_has_trackerid();
  if (trackerid_ == &::google::protobuf::internal::kEmptyString) {
    trackerid_ = new ::std::string;
  }
  trackerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestTrackerIdentityAuthentication::mutable_trackerid() {
  set_has_trackerid();
  if (trackerid_ == &::google::protobuf::internal::kEmptyString) {
    trackerid_ = new ::std::string;
  }
  return trackerid_;
}
inline ::std::string* RequestTrackerIdentityAuthentication::release_trackerid() {
  clear_has_trackerid();
  if (trackerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = trackerid_;
    trackerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestTrackerIdentityAuthentication::set_allocated_trackerid(::std::string* trackerid) {
  if (trackerid_ != &::google::protobuf::internal::kEmptyString) {
    delete trackerid_;
  }
  if (trackerid) {
    set_has_trackerid();
    trackerid_ = trackerid;
  } else {
    clear_has_trackerid();
    trackerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string extradata = 3;
inline bool RequestTrackerIdentityAuthentication::has_extradata() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestTrackerIdentityAuthentication::set_has_extradata() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestTrackerIdentityAuthentication::clear_has_extradata() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestTrackerIdentityAuthentication::clear_extradata() {
  if (extradata_ != &::google::protobuf::internal::kEmptyString) {
    extradata_->clear();
  }
  clear_has_extradata();
}
inline const ::std::string& RequestTrackerIdentityAuthentication::extradata() const {
  return *extradata_;
}
inline void RequestTrackerIdentityAuthentication::set_extradata(const ::std::string& value) {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  extradata_->assign(value);
}
inline void RequestTrackerIdentityAuthentication::set_extradata(const char* value) {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  extradata_->assign(value);
}
inline void RequestTrackerIdentityAuthentication::set_extradata(const char* value, size_t size) {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  extradata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestTrackerIdentityAuthentication::mutable_extradata() {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  return extradata_;
}
inline ::std::string* RequestTrackerIdentityAuthentication::release_extradata() {
  clear_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = extradata_;
    extradata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestTrackerIdentityAuthentication::set_allocated_extradata(::std::string* extradata) {
  if (extradata_ != &::google::protobuf::internal::kEmptyString) {
    delete extradata_;
  }
  if (extradata) {
    set_has_extradata();
    extradata_ = extradata;
  } else {
    clear_has_extradata();
    extradata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AckTrackerIdentityAuthentication

// required uint32 seqno = 1;
inline bool AckTrackerIdentityAuthentication::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckTrackerIdentityAuthentication::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckTrackerIdentityAuthentication::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckTrackerIdentityAuthentication::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 AckTrackerIdentityAuthentication::seqno() const {
  return seqno_;
}
inline void AckTrackerIdentityAuthentication::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required int32 result = 2;
inline bool AckTrackerIdentityAuthentication::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckTrackerIdentityAuthentication::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckTrackerIdentityAuthentication::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckTrackerIdentityAuthentication::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 AckTrackerIdentityAuthentication::result() const {
  return result_;
}
inline void AckTrackerIdentityAuthentication::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional string extradata = 3;
inline bool AckTrackerIdentityAuthentication::has_extradata() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckTrackerIdentityAuthentication::set_has_extradata() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckTrackerIdentityAuthentication::clear_has_extradata() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckTrackerIdentityAuthentication::clear_extradata() {
  if (extradata_ != &::google::protobuf::internal::kEmptyString) {
    extradata_->clear();
  }
  clear_has_extradata();
}
inline const ::std::string& AckTrackerIdentityAuthentication::extradata() const {
  return *extradata_;
}
inline void AckTrackerIdentityAuthentication::set_extradata(const ::std::string& value) {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  extradata_->assign(value);
}
inline void AckTrackerIdentityAuthentication::set_extradata(const char* value) {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  extradata_->assign(value);
}
inline void AckTrackerIdentityAuthentication::set_extradata(const char* value, size_t size) {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  extradata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckTrackerIdentityAuthentication::mutable_extradata() {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  return extradata_;
}
inline ::std::string* AckTrackerIdentityAuthentication::release_extradata() {
  clear_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = extradata_;
    extradata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AckTrackerIdentityAuthentication::set_allocated_extradata(::std::string* extradata) {
  if (extradata_ != &::google::protobuf::internal::kEmptyString) {
    delete extradata_;
  }
  if (extradata) {
    set_has_extradata();
    extradata_ = extradata;
  } else {
    clear_has_extradata();
    extradata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Request3rdIdentityAuthentication

// required uint32 seqno = 1;
inline bool Request3rdIdentityAuthentication::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request3rdIdentityAuthentication::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request3rdIdentityAuthentication::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request3rdIdentityAuthentication::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 Request3rdIdentityAuthentication::seqno() const {
  return seqno_;
}
inline void Request3rdIdentityAuthentication::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required string identification = 2;
inline bool Request3rdIdentityAuthentication::has_identification() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Request3rdIdentityAuthentication::set_has_identification() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Request3rdIdentityAuthentication::clear_has_identification() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Request3rdIdentityAuthentication::clear_identification() {
  if (identification_ != &::google::protobuf::internal::kEmptyString) {
    identification_->clear();
  }
  clear_has_identification();
}
inline const ::std::string& Request3rdIdentityAuthentication::identification() const {
  return *identification_;
}
inline void Request3rdIdentityAuthentication::set_identification(const ::std::string& value) {
  set_has_identification();
  if (identification_ == &::google::protobuf::internal::kEmptyString) {
    identification_ = new ::std::string;
  }
  identification_->assign(value);
}
inline void Request3rdIdentityAuthentication::set_identification(const char* value) {
  set_has_identification();
  if (identification_ == &::google::protobuf::internal::kEmptyString) {
    identification_ = new ::std::string;
  }
  identification_->assign(value);
}
inline void Request3rdIdentityAuthentication::set_identification(const char* value, size_t size) {
  set_has_identification();
  if (identification_ == &::google::protobuf::internal::kEmptyString) {
    identification_ = new ::std::string;
  }
  identification_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Request3rdIdentityAuthentication::mutable_identification() {
  set_has_identification();
  if (identification_ == &::google::protobuf::internal::kEmptyString) {
    identification_ = new ::std::string;
  }
  return identification_;
}
inline ::std::string* Request3rdIdentityAuthentication::release_identification() {
  clear_has_identification();
  if (identification_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = identification_;
    identification_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Request3rdIdentityAuthentication::set_allocated_identification(::std::string* identification) {
  if (identification_ != &::google::protobuf::internal::kEmptyString) {
    delete identification_;
  }
  if (identification) {
    set_has_identification();
    identification_ = identification;
  } else {
    clear_has_identification();
    identification_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string secretkey = 3;
inline bool Request3rdIdentityAuthentication::has_secretkey() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Request3rdIdentityAuthentication::set_has_secretkey() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Request3rdIdentityAuthentication::clear_has_secretkey() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Request3rdIdentityAuthentication::clear_secretkey() {
  if (secretkey_ != &::google::protobuf::internal::kEmptyString) {
    secretkey_->clear();
  }
  clear_has_secretkey();
}
inline const ::std::string& Request3rdIdentityAuthentication::secretkey() const {
  return *secretkey_;
}
inline void Request3rdIdentityAuthentication::set_secretkey(const ::std::string& value) {
  set_has_secretkey();
  if (secretkey_ == &::google::protobuf::internal::kEmptyString) {
    secretkey_ = new ::std::string;
  }
  secretkey_->assign(value);
}
inline void Request3rdIdentityAuthentication::set_secretkey(const char* value) {
  set_has_secretkey();
  if (secretkey_ == &::google::protobuf::internal::kEmptyString) {
    secretkey_ = new ::std::string;
  }
  secretkey_->assign(value);
}
inline void Request3rdIdentityAuthentication::set_secretkey(const char* value, size_t size) {
  set_has_secretkey();
  if (secretkey_ == &::google::protobuf::internal::kEmptyString) {
    secretkey_ = new ::std::string;
  }
  secretkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Request3rdIdentityAuthentication::mutable_secretkey() {
  set_has_secretkey();
  if (secretkey_ == &::google::protobuf::internal::kEmptyString) {
    secretkey_ = new ::std::string;
  }
  return secretkey_;
}
inline ::std::string* Request3rdIdentityAuthentication::release_secretkey() {
  clear_has_secretkey();
  if (secretkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = secretkey_;
    secretkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Request3rdIdentityAuthentication::set_allocated_secretkey(::std::string* secretkey) {
  if (secretkey_ != &::google::protobuf::internal::kEmptyString) {
    delete secretkey_;
  }
  if (secretkey) {
    set_has_secretkey();
    secretkey_ = secretkey;
  } else {
    clear_has_secretkey();
    secretkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string extradata = 4;
inline bool Request3rdIdentityAuthentication::has_extradata() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Request3rdIdentityAuthentication::set_has_extradata() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Request3rdIdentityAuthentication::clear_has_extradata() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Request3rdIdentityAuthentication::clear_extradata() {
  if (extradata_ != &::google::protobuf::internal::kEmptyString) {
    extradata_->clear();
  }
  clear_has_extradata();
}
inline const ::std::string& Request3rdIdentityAuthentication::extradata() const {
  return *extradata_;
}
inline void Request3rdIdentityAuthentication::set_extradata(const ::std::string& value) {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  extradata_->assign(value);
}
inline void Request3rdIdentityAuthentication::set_extradata(const char* value) {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  extradata_->assign(value);
}
inline void Request3rdIdentityAuthentication::set_extradata(const char* value, size_t size) {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  extradata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Request3rdIdentityAuthentication::mutable_extradata() {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  return extradata_;
}
inline ::std::string* Request3rdIdentityAuthentication::release_extradata() {
  clear_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = extradata_;
    extradata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Request3rdIdentityAuthentication::set_allocated_extradata(::std::string* extradata) {
  if (extradata_ != &::google::protobuf::internal::kEmptyString) {
    delete extradata_;
  }
  if (extradata) {
    set_has_extradata();
    extradata_ = extradata;
  } else {
    clear_has_extradata();
    extradata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Ack3rdIdentityAuthentication

// required uint32 seqno = 1;
inline bool Ack3rdIdentityAuthentication::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Ack3rdIdentityAuthentication::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Ack3rdIdentityAuthentication::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Ack3rdIdentityAuthentication::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 Ack3rdIdentityAuthentication::seqno() const {
  return seqno_;
}
inline void Ack3rdIdentityAuthentication::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required int32 result = 2;
inline bool Ack3rdIdentityAuthentication::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Ack3rdIdentityAuthentication::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Ack3rdIdentityAuthentication::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Ack3rdIdentityAuthentication::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 Ack3rdIdentityAuthentication::result() const {
  return result_;
}
inline void Ack3rdIdentityAuthentication::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional string extradata = 3;
inline bool Ack3rdIdentityAuthentication::has_extradata() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Ack3rdIdentityAuthentication::set_has_extradata() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Ack3rdIdentityAuthentication::clear_has_extradata() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Ack3rdIdentityAuthentication::clear_extradata() {
  if (extradata_ != &::google::protobuf::internal::kEmptyString) {
    extradata_->clear();
  }
  clear_has_extradata();
}
inline const ::std::string& Ack3rdIdentityAuthentication::extradata() const {
  return *extradata_;
}
inline void Ack3rdIdentityAuthentication::set_extradata(const ::std::string& value) {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  extradata_->assign(value);
}
inline void Ack3rdIdentityAuthentication::set_extradata(const char* value) {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  extradata_->assign(value);
}
inline void Ack3rdIdentityAuthentication::set_extradata(const char* value, size_t size) {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  extradata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Ack3rdIdentityAuthentication::mutable_extradata() {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  return extradata_;
}
inline ::std::string* Ack3rdIdentityAuthentication::release_extradata() {
  clear_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = extradata_;
    extradata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Ack3rdIdentityAuthentication::set_allocated_extradata(::std::string* extradata) {
  if (extradata_ != &::google::protobuf::internal::kEmptyString) {
    delete extradata_;
  }
  if (extradata) {
    set_has_extradata();
    extradata_ = extradata;
  } else {
    clear_has_extradata();
    extradata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RequestUavIdentityAuthentication

// required uint32 seqno = 1;
inline bool RequestUavIdentityAuthentication::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestUavIdentityAuthentication::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestUavIdentityAuthentication::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestUavIdentityAuthentication::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 RequestUavIdentityAuthentication::seqno() const {
  return seqno_;
}
inline void RequestUavIdentityAuthentication::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required string uavid = 2;
inline bool RequestUavIdentityAuthentication::has_uavid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestUavIdentityAuthentication::set_has_uavid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestUavIdentityAuthentication::clear_has_uavid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestUavIdentityAuthentication::clear_uavid() {
  if (uavid_ != &::google::protobuf::internal::kEmptyString) {
    uavid_->clear();
  }
  clear_has_uavid();
}
inline const ::std::string& RequestUavIdentityAuthentication::uavid() const {
  return *uavid_;
}
inline void RequestUavIdentityAuthentication::set_uavid(const ::std::string& value) {
  set_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    uavid_ = new ::std::string;
  }
  uavid_->assign(value);
}
inline void RequestUavIdentityAuthentication::set_uavid(const char* value) {
  set_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    uavid_ = new ::std::string;
  }
  uavid_->assign(value);
}
inline void RequestUavIdentityAuthentication::set_uavid(const char* value, size_t size) {
  set_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    uavid_ = new ::std::string;
  }
  uavid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestUavIdentityAuthentication::mutable_uavid() {
  set_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    uavid_ = new ::std::string;
  }
  return uavid_;
}
inline ::std::string* RequestUavIdentityAuthentication::release_uavid() {
  clear_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uavid_;
    uavid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestUavIdentityAuthentication::set_allocated_uavid(::std::string* uavid) {
  if (uavid_ != &::google::protobuf::internal::kEmptyString) {
    delete uavid_;
  }
  if (uavid) {
    set_has_uavid();
    uavid_ = uavid;
  } else {
    clear_has_uavid();
    uavid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string extradata = 3;
inline bool RequestUavIdentityAuthentication::has_extradata() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestUavIdentityAuthentication::set_has_extradata() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestUavIdentityAuthentication::clear_has_extradata() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestUavIdentityAuthentication::clear_extradata() {
  if (extradata_ != &::google::protobuf::internal::kEmptyString) {
    extradata_->clear();
  }
  clear_has_extradata();
}
inline const ::std::string& RequestUavIdentityAuthentication::extradata() const {
  return *extradata_;
}
inline void RequestUavIdentityAuthentication::set_extradata(const ::std::string& value) {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  extradata_->assign(value);
}
inline void RequestUavIdentityAuthentication::set_extradata(const char* value) {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  extradata_->assign(value);
}
inline void RequestUavIdentityAuthentication::set_extradata(const char* value, size_t size) {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  extradata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestUavIdentityAuthentication::mutable_extradata() {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  return extradata_;
}
inline ::std::string* RequestUavIdentityAuthentication::release_extradata() {
  clear_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = extradata_;
    extradata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestUavIdentityAuthentication::set_allocated_extradata(::std::string* extradata) {
  if (extradata_ != &::google::protobuf::internal::kEmptyString) {
    delete extradata_;
  }
  if (extradata) {
    set_has_extradata();
    extradata_ = extradata;
  } else {
    clear_has_extradata();
    extradata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AckUavIdentityAuthentication

// required uint32 seqno = 1;
inline bool AckUavIdentityAuthentication::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckUavIdentityAuthentication::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckUavIdentityAuthentication::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckUavIdentityAuthentication::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 AckUavIdentityAuthentication::seqno() const {
  return seqno_;
}
inline void AckUavIdentityAuthentication::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// optional string uavid = 2;
inline bool AckUavIdentityAuthentication::has_uavid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckUavIdentityAuthentication::set_has_uavid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckUavIdentityAuthentication::clear_has_uavid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckUavIdentityAuthentication::clear_uavid() {
  if (uavid_ != &::google::protobuf::internal::kEmptyString) {
    uavid_->clear();
  }
  clear_has_uavid();
}
inline const ::std::string& AckUavIdentityAuthentication::uavid() const {
  return *uavid_;
}
inline void AckUavIdentityAuthentication::set_uavid(const ::std::string& value) {
  set_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    uavid_ = new ::std::string;
  }
  uavid_->assign(value);
}
inline void AckUavIdentityAuthentication::set_uavid(const char* value) {
  set_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    uavid_ = new ::std::string;
  }
  uavid_->assign(value);
}
inline void AckUavIdentityAuthentication::set_uavid(const char* value, size_t size) {
  set_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    uavid_ = new ::std::string;
  }
  uavid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckUavIdentityAuthentication::mutable_uavid() {
  set_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    uavid_ = new ::std::string;
  }
  return uavid_;
}
inline ::std::string* AckUavIdentityAuthentication::release_uavid() {
  clear_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uavid_;
    uavid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AckUavIdentityAuthentication::set_allocated_uavid(::std::string* uavid) {
  if (uavid_ != &::google::protobuf::internal::kEmptyString) {
    delete uavid_;
  }
  if (uavid) {
    set_has_uavid();
    uavid_ = uavid;
  } else {
    clear_has_uavid();
    uavid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 result = 3;
inline bool AckUavIdentityAuthentication::has_result() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckUavIdentityAuthentication::set_has_result() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckUavIdentityAuthentication::clear_has_result() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckUavIdentityAuthentication::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 AckUavIdentityAuthentication::result() const {
  return result_;
}
inline void AckUavIdentityAuthentication::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional uint64 deadline = 4;
inline bool AckUavIdentityAuthentication::has_deadline() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AckUavIdentityAuthentication::set_has_deadline() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AckUavIdentityAuthentication::clear_has_deadline() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AckUavIdentityAuthentication::clear_deadline() {
  deadline_ = GOOGLE_ULONGLONG(0);
  clear_has_deadline();
}
inline ::google::protobuf::uint64 AckUavIdentityAuthentication::deadline() const {
  return deadline_;
}
inline void AckUavIdentityAuthentication::set_deadline(::google::protobuf::uint64 value) {
  set_has_deadline();
  deadline_ = value;
}

// optional string authString = 5;
inline bool AckUavIdentityAuthentication::has_authstring() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AckUavIdentityAuthentication::set_has_authstring() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AckUavIdentityAuthentication::clear_has_authstring() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AckUavIdentityAuthentication::clear_authstring() {
  if (authstring_ != &::google::protobuf::internal::kEmptyString) {
    authstring_->clear();
  }
  clear_has_authstring();
}
inline const ::std::string& AckUavIdentityAuthentication::authstring() const {
  return *authstring_;
}
inline void AckUavIdentityAuthentication::set_authstring(const ::std::string& value) {
  set_has_authstring();
  if (authstring_ == &::google::protobuf::internal::kEmptyString) {
    authstring_ = new ::std::string;
  }
  authstring_->assign(value);
}
inline void AckUavIdentityAuthentication::set_authstring(const char* value) {
  set_has_authstring();
  if (authstring_ == &::google::protobuf::internal::kEmptyString) {
    authstring_ = new ::std::string;
  }
  authstring_->assign(value);
}
inline void AckUavIdentityAuthentication::set_authstring(const char* value, size_t size) {
  set_has_authstring();
  if (authstring_ == &::google::protobuf::internal::kEmptyString) {
    authstring_ = new ::std::string;
  }
  authstring_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckUavIdentityAuthentication::mutable_authstring() {
  set_has_authstring();
  if (authstring_ == &::google::protobuf::internal::kEmptyString) {
    authstring_ = new ::std::string;
  }
  return authstring_;
}
inline ::std::string* AckUavIdentityAuthentication::release_authstring() {
  clear_has_authstring();
  if (authstring_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = authstring_;
    authstring_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AckUavIdentityAuthentication::set_allocated_authstring(::std::string* authstring) {
  if (authstring_ != &::google::protobuf::internal::kEmptyString) {
    delete authstring_;
  }
  if (authstring) {
    set_has_authstring();
    authstring_ = authstring;
  } else {
    clear_has_authstring();
    authstring_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GpsInformation

// required int32 longitude = 1;
inline bool GpsInformation::has_longitude() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GpsInformation::set_has_longitude() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GpsInformation::clear_has_longitude() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GpsInformation::clear_longitude() {
  longitude_ = 0;
  clear_has_longitude();
}
inline ::google::protobuf::int32 GpsInformation::longitude() const {
  return longitude_;
}
inline void GpsInformation::set_longitude(::google::protobuf::int32 value) {
  set_has_longitude();
  longitude_ = value;
}

// required int32 latitude = 2;
inline bool GpsInformation::has_latitude() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GpsInformation::set_has_latitude() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GpsInformation::clear_has_latitude() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GpsInformation::clear_latitude() {
  latitude_ = 0;
  clear_has_latitude();
}
inline ::google::protobuf::int32 GpsInformation::latitude() const {
  return latitude_;
}
inline void GpsInformation::set_latitude(::google::protobuf::int32 value) {
  set_has_latitude();
  latitude_ = value;
}

// required int32 altitude = 3;
inline bool GpsInformation::has_altitude() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GpsInformation::set_has_altitude() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GpsInformation::clear_has_altitude() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GpsInformation::clear_altitude() {
  altitude_ = 0;
  clear_has_altitude();
}
inline ::google::protobuf::int32 GpsInformation::altitude() const {
  return altitude_;
}
inline void GpsInformation::set_altitude(::google::protobuf::int32 value) {
  set_has_altitude();
  altitude_ = value;
}

// repeated float velocity = 4;
inline int GpsInformation::velocity_size() const {
  return velocity_.size();
}
inline void GpsInformation::clear_velocity() {
  velocity_.Clear();
}
inline float GpsInformation::velocity(int index) const {
  return velocity_.Get(index);
}
inline void GpsInformation::set_velocity(int index, float value) {
  velocity_.Set(index, value);
}
inline void GpsInformation::add_velocity(float value) {
  velocity_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
GpsInformation::velocity() const {
  return velocity_;
}
inline ::google::protobuf::RepeatedField< float >*
GpsInformation::mutable_velocity() {
  return &velocity_;
}

// -------------------------------------------------------------------

// OperationStatus

// optional string operationmode = 1;
inline bool OperationStatus::has_operationmode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OperationStatus::set_has_operationmode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OperationStatus::clear_has_operationmode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OperationStatus::clear_operationmode() {
  if (operationmode_ != &::google::protobuf::internal::kEmptyString) {
    operationmode_->clear();
  }
  clear_has_operationmode();
}
inline const ::std::string& OperationStatus::operationmode() const {
  return *operationmode_;
}
inline void OperationStatus::set_operationmode(const ::std::string& value) {
  set_has_operationmode();
  if (operationmode_ == &::google::protobuf::internal::kEmptyString) {
    operationmode_ = new ::std::string;
  }
  operationmode_->assign(value);
}
inline void OperationStatus::set_operationmode(const char* value) {
  set_has_operationmode();
  if (operationmode_ == &::google::protobuf::internal::kEmptyString) {
    operationmode_ = new ::std::string;
  }
  operationmode_->assign(value);
}
inline void OperationStatus::set_operationmode(const char* value, size_t size) {
  set_has_operationmode();
  if (operationmode_ == &::google::protobuf::internal::kEmptyString) {
    operationmode_ = new ::std::string;
  }
  operationmode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OperationStatus::mutable_operationmode() {
  set_has_operationmode();
  if (operationmode_ == &::google::protobuf::internal::kEmptyString) {
    operationmode_ = new ::std::string;
  }
  return operationmode_;
}
inline ::std::string* OperationStatus::release_operationmode() {
  clear_has_operationmode();
  if (operationmode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = operationmode_;
    operationmode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OperationStatus::set_allocated_operationmode(::std::string* operationmode) {
  if (operationmode_ != &::google::protobuf::internal::kEmptyString) {
    delete operationmode_;
  }
  if (operationmode) {
    set_has_operationmode();
    operationmode_ = operationmode;
  } else {
    clear_has_operationmode();
    operationmode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float voltage = 2;
inline bool OperationStatus::has_voltage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OperationStatus::set_has_voltage() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OperationStatus::clear_has_voltage() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OperationStatus::clear_voltage() {
  voltage_ = 0;
  clear_has_voltage();
}
inline float OperationStatus::voltage() const {
  return voltage_;
}
inline void OperationStatus::set_voltage(float value) {
  set_has_voltage();
  voltage_ = value;
}

// optional float surplusenergy = 3;
inline bool OperationStatus::has_surplusenergy() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OperationStatus::set_has_surplusenergy() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OperationStatus::clear_has_surplusenergy() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OperationStatus::clear_surplusenergy() {
  surplusenergy_ = 0;
  clear_has_surplusenergy();
}
inline float OperationStatus::surplusenergy() const {
  return surplusenergy_;
}
inline void OperationStatus::set_surplusenergy(float value) {
  set_has_surplusenergy();
  surplusenergy_ = value;
}

// optional float jetvelocity = 4;
inline bool OperationStatus::has_jetvelocity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OperationStatus::set_has_jetvelocity() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OperationStatus::clear_has_jetvelocity() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OperationStatus::clear_jetvelocity() {
  jetvelocity_ = 0;
  clear_has_jetvelocity();
}
inline float OperationStatus::jetvelocity() const {
  return jetvelocity_;
}
inline void OperationStatus::set_jetvelocity(float value) {
  set_has_jetvelocity();
  jetvelocity_ = value;
}

// optional float sprayeddose = 5;
inline bool OperationStatus::has_sprayeddose() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OperationStatus::set_has_sprayeddose() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OperationStatus::clear_has_sprayeddose() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OperationStatus::clear_sprayeddose() {
  sprayeddose_ = 0;
  clear_has_sprayeddose();
}
inline float OperationStatus::sprayeddose() const {
  return sprayeddose_;
}
inline void OperationStatus::set_sprayeddose(float value) {
  set_has_sprayeddose();
  sprayeddose_ = value;
}

// -------------------------------------------------------------------

// OperationParams

// optional float alarmvoltage = 1;
inline bool OperationParams::has_alarmvoltage() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OperationParams::set_has_alarmvoltage() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OperationParams::clear_has_alarmvoltage() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OperationParams::clear_alarmvoltage() {
  alarmvoltage_ = 0;
  clear_has_alarmvoltage();
}
inline float OperationParams::alarmvoltage() const {
  return alarmvoltage_;
}
inline void OperationParams::set_alarmvoltage(float value) {
  set_has_alarmvoltage();
  alarmvoltage_ = value;
}

// optional float alarmdose = 2;
inline bool OperationParams::has_alarmdose() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OperationParams::set_has_alarmdose() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OperationParams::clear_has_alarmdose() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OperationParams::clear_alarmdose() {
  alarmdose_ = 0;
  clear_has_alarmdose();
}
inline float OperationParams::alarmdose() const {
  return alarmdose_;
}
inline void OperationParams::set_alarmdose(float value) {
  set_has_alarmdose();
  alarmdose_ = value;
}

// optional float sprayingwidth = 3;
inline bool OperationParams::has_sprayingwidth() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OperationParams::set_has_sprayingwidth() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OperationParams::clear_has_sprayingwidth() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OperationParams::clear_sprayingwidth() {
  sprayingwidth_ = 0;
  clear_has_sprayingwidth();
}
inline float OperationParams::sprayingwidth() const {
  return sprayingwidth_;
}
inline void OperationParams::set_sprayingwidth(float value) {
  set_has_sprayingwidth();
  sprayingwidth_ = value;
}

// optional float desiredaltitude = 4;
inline bool OperationParams::has_desiredaltitude() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OperationParams::set_has_desiredaltitude() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OperationParams::clear_has_desiredaltitude() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OperationParams::clear_desiredaltitude() {
  desiredaltitude_ = 0;
  clear_has_desiredaltitude();
}
inline float OperationParams::desiredaltitude() const {
  return desiredaltitude_;
}
inline void OperationParams::set_desiredaltitude(float value) {
  set_has_desiredaltitude();
  desiredaltitude_ = value;
}

// optional float desiredvelocity = 5;
inline bool OperationParams::has_desiredvelocity() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OperationParams::set_has_desiredvelocity() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OperationParams::clear_has_desiredvelocity() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OperationParams::clear_desiredvelocity() {
  desiredvelocity_ = 0;
  clear_has_desiredvelocity();
}
inline float OperationParams::desiredvelocity() const {
  return desiredvelocity_;
}
inline void OperationParams::set_desiredvelocity(float value) {
  set_has_desiredvelocity();
  desiredvelocity_ = value;
}

// optional float jetvelocity = 6;
inline bool OperationParams::has_jetvelocity() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void OperationParams::set_has_jetvelocity() {
  _has_bits_[0] |= 0x00000020u;
}
inline void OperationParams::clear_has_jetvelocity() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void OperationParams::clear_jetvelocity() {
  jetvelocity_ = 0;
  clear_has_jetvelocity();
}
inline float OperationParams::jetvelocity() const {
  return jetvelocity_;
}
inline void OperationParams::set_jetvelocity(float value) {
  set_has_jetvelocity();
  jetvelocity_ = value;
}

// -------------------------------------------------------------------

// OperationInformation

// required string uavid = 1;
inline bool OperationInformation::has_uavid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OperationInformation::set_has_uavid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OperationInformation::clear_has_uavid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OperationInformation::clear_uavid() {
  if (uavid_ != &::google::protobuf::internal::kEmptyString) {
    uavid_->clear();
  }
  clear_has_uavid();
}
inline const ::std::string& OperationInformation::uavid() const {
  return *uavid_;
}
inline void OperationInformation::set_uavid(const ::std::string& value) {
  set_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    uavid_ = new ::std::string;
  }
  uavid_->assign(value);
}
inline void OperationInformation::set_uavid(const char* value) {
  set_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    uavid_ = new ::std::string;
  }
  uavid_->assign(value);
}
inline void OperationInformation::set_uavid(const char* value, size_t size) {
  set_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    uavid_ = new ::std::string;
  }
  uavid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OperationInformation::mutable_uavid() {
  set_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    uavid_ = new ::std::string;
  }
  return uavid_;
}
inline ::std::string* OperationInformation::release_uavid() {
  clear_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uavid_;
    uavid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OperationInformation::set_allocated_uavid(::std::string* uavid) {
  if (uavid_ != &::google::protobuf::internal::kEmptyString) {
    delete uavid_;
  }
  if (uavid) {
    set_has_uavid();
    uavid_ = uavid;
  } else {
    clear_has_uavid();
    uavid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint64 timestamp = 2;
inline bool OperationInformation::has_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OperationInformation::set_has_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OperationInformation::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OperationInformation::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 OperationInformation::timestamp() const {
  return timestamp_;
}
inline void OperationInformation::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// required .das.proto.GpsInformation gps = 3;
inline bool OperationInformation::has_gps() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OperationInformation::set_has_gps() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OperationInformation::clear_has_gps() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OperationInformation::clear_gps() {
  if (gps_ != NULL) gps_->::das::proto::GpsInformation::Clear();
  clear_has_gps();
}
inline const ::das::proto::GpsInformation& OperationInformation::gps() const {
  return gps_ != NULL ? *gps_ : *default_instance_->gps_;
}
inline ::das::proto::GpsInformation* OperationInformation::mutable_gps() {
  set_has_gps();
  if (gps_ == NULL) gps_ = new ::das::proto::GpsInformation;
  return gps_;
}
inline ::das::proto::GpsInformation* OperationInformation::release_gps() {
  clear_has_gps();
  ::das::proto::GpsInformation* temp = gps_;
  gps_ = NULL;
  return temp;
}
inline void OperationInformation::set_allocated_gps(::das::proto::GpsInformation* gps) {
  delete gps_;
  gps_ = gps;
  if (gps) {
    set_has_gps();
  } else {
    clear_has_gps();
  }
}

// optional .das.proto.OperationStatus status = 4;
inline bool OperationInformation::has_status() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OperationInformation::set_has_status() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OperationInformation::clear_has_status() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OperationInformation::clear_status() {
  if (status_ != NULL) status_->::das::proto::OperationStatus::Clear();
  clear_has_status();
}
inline const ::das::proto::OperationStatus& OperationInformation::status() const {
  return status_ != NULL ? *status_ : *default_instance_->status_;
}
inline ::das::proto::OperationStatus* OperationInformation::mutable_status() {
  set_has_status();
  if (status_ == NULL) status_ = new ::das::proto::OperationStatus;
  return status_;
}
inline ::das::proto::OperationStatus* OperationInformation::release_status() {
  clear_has_status();
  ::das::proto::OperationStatus* temp = status_;
  status_ = NULL;
  return temp;
}
inline void OperationInformation::set_allocated_status(::das::proto::OperationStatus* status) {
  delete status_;
  status_ = status;
  if (status) {
    set_has_status();
  } else {
    clear_has_status();
  }
}

// optional .das.proto.OperationParams params = 5;
inline bool OperationInformation::has_params() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OperationInformation::set_has_params() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OperationInformation::clear_has_params() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OperationInformation::clear_params() {
  if (params_ != NULL) params_->::das::proto::OperationParams::Clear();
  clear_has_params();
}
inline const ::das::proto::OperationParams& OperationInformation::params() const {
  return params_ != NULL ? *params_ : *default_instance_->params_;
}
inline ::das::proto::OperationParams* OperationInformation::mutable_params() {
  set_has_params();
  if (params_ == NULL) params_ = new ::das::proto::OperationParams;
  return params_;
}
inline ::das::proto::OperationParams* OperationInformation::release_params() {
  clear_has_params();
  ::das::proto::OperationParams* temp = params_;
  params_ = NULL;
  return temp;
}
inline void OperationInformation::set_allocated_params(::das::proto::OperationParams* params) {
  delete params_;
  params_ = params;
  if (params) {
    set_has_params();
  } else {
    clear_has_params();
  }
}

// -------------------------------------------------------------------

// PostOperationInformation

// required uint32 seqno = 1;
inline bool PostOperationInformation::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PostOperationInformation::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PostOperationInformation::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PostOperationInformation::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 PostOperationInformation::seqno() const {
  return seqno_;
}
inline void PostOperationInformation::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// repeated .das.proto.OperationInformation oi = 2;
inline int PostOperationInformation::oi_size() const {
  return oi_.size();
}
inline void PostOperationInformation::clear_oi() {
  oi_.Clear();
}
inline const ::das::proto::OperationInformation& PostOperationInformation::oi(int index) const {
  return oi_.Get(index);
}
inline ::das::proto::OperationInformation* PostOperationInformation::mutable_oi(int index) {
  return oi_.Mutable(index);
}
inline ::das::proto::OperationInformation* PostOperationInformation::add_oi() {
  return oi_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::das::proto::OperationInformation >&
PostOperationInformation::oi() const {
  return oi_;
}
inline ::google::protobuf::RepeatedPtrField< ::das::proto::OperationInformation >*
PostOperationInformation::mutable_oi() {
  return &oi_;
}

// -------------------------------------------------------------------

// AckOperationInformation

// required uint32 seqno = 1;
inline bool AckOperationInformation::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckOperationInformation::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckOperationInformation::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckOperationInformation::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 AckOperationInformation::seqno() const {
  return seqno_;
}
inline void AckOperationInformation::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required int32 result = 2;
inline bool AckOperationInformation::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckOperationInformation::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckOperationInformation::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckOperationInformation::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 AckOperationInformation::result() const {
  return result_;
}
inline void AckOperationInformation::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// RequestIdentityAllocation

// required uint32 seqno = 1;
inline bool RequestIdentityAllocation::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestIdentityAllocation::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestIdentityAllocation::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestIdentityAllocation::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 RequestIdentityAllocation::seqno() const {
  return seqno_;
}
inline void RequestIdentityAllocation::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required string devtype = 2;
inline bool RequestIdentityAllocation::has_devtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestIdentityAllocation::set_has_devtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestIdentityAllocation::clear_has_devtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestIdentityAllocation::clear_devtype() {
  if (devtype_ != &::google::protobuf::internal::kEmptyString) {
    devtype_->clear();
  }
  clear_has_devtype();
}
inline const ::std::string& RequestIdentityAllocation::devtype() const {
  return *devtype_;
}
inline void RequestIdentityAllocation::set_devtype(const ::std::string& value) {
  set_has_devtype();
  if (devtype_ == &::google::protobuf::internal::kEmptyString) {
    devtype_ = new ::std::string;
  }
  devtype_->assign(value);
}
inline void RequestIdentityAllocation::set_devtype(const char* value) {
  set_has_devtype();
  if (devtype_ == &::google::protobuf::internal::kEmptyString) {
    devtype_ = new ::std::string;
  }
  devtype_->assign(value);
}
inline void RequestIdentityAllocation::set_devtype(const char* value, size_t size) {
  set_has_devtype();
  if (devtype_ == &::google::protobuf::internal::kEmptyString) {
    devtype_ = new ::std::string;
  }
  devtype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestIdentityAllocation::mutable_devtype() {
  set_has_devtype();
  if (devtype_ == &::google::protobuf::internal::kEmptyString) {
    devtype_ = new ::std::string;
  }
  return devtype_;
}
inline ::std::string* RequestIdentityAllocation::release_devtype() {
  clear_has_devtype();
  if (devtype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = devtype_;
    devtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestIdentityAllocation::set_allocated_devtype(::std::string* devtype) {
  if (devtype_ != &::google::protobuf::internal::kEmptyString) {
    delete devtype_;
  }
  if (devtype) {
    set_has_devtype();
    devtype_ = devtype;
  } else {
    clear_has_devtype();
    devtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string extradata = 3;
inline bool RequestIdentityAllocation::has_extradata() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestIdentityAllocation::set_has_extradata() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestIdentityAllocation::clear_has_extradata() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestIdentityAllocation::clear_extradata() {
  if (extradata_ != &::google::protobuf::internal::kEmptyString) {
    extradata_->clear();
  }
  clear_has_extradata();
}
inline const ::std::string& RequestIdentityAllocation::extradata() const {
  return *extradata_;
}
inline void RequestIdentityAllocation::set_extradata(const ::std::string& value) {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  extradata_->assign(value);
}
inline void RequestIdentityAllocation::set_extradata(const char* value) {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  extradata_->assign(value);
}
inline void RequestIdentityAllocation::set_extradata(const char* value, size_t size) {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  extradata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestIdentityAllocation::mutable_extradata() {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  return extradata_;
}
inline ::std::string* RequestIdentityAllocation::release_extradata() {
  clear_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = extradata_;
    extradata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestIdentityAllocation::set_allocated_extradata(::std::string* extradata) {
  if (extradata_ != &::google::protobuf::internal::kEmptyString) {
    delete extradata_;
  }
  if (extradata) {
    set_has_extradata();
    extradata_ = extradata;
  } else {
    clear_has_extradata();
    extradata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AckIdentityAllocation

// required uint32 seqno = 1;
inline bool AckIdentityAllocation::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckIdentityAllocation::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckIdentityAllocation::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckIdentityAllocation::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 AckIdentityAllocation::seqno() const {
  return seqno_;
}
inline void AckIdentityAllocation::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required int32 result = 2;
inline bool AckIdentityAllocation::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckIdentityAllocation::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckIdentityAllocation::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckIdentityAllocation::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 AckIdentityAllocation::result() const {
  return result_;
}
inline void AckIdentityAllocation::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional string id = 3;
inline bool AckIdentityAllocation::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckIdentityAllocation::set_has_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckIdentityAllocation::clear_has_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckIdentityAllocation::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& AckIdentityAllocation::id() const {
  return *id_;
}
inline void AckIdentityAllocation::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void AckIdentityAllocation::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void AckIdentityAllocation::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckIdentityAllocation::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* AckIdentityAllocation::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AckIdentityAllocation::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string extradata = 4;
inline bool AckIdentityAllocation::has_extradata() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AckIdentityAllocation::set_has_extradata() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AckIdentityAllocation::clear_has_extradata() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AckIdentityAllocation::clear_extradata() {
  if (extradata_ != &::google::protobuf::internal::kEmptyString) {
    extradata_->clear();
  }
  clear_has_extradata();
}
inline const ::std::string& AckIdentityAllocation::extradata() const {
  return *extradata_;
}
inline void AckIdentityAllocation::set_extradata(const ::std::string& value) {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  extradata_->assign(value);
}
inline void AckIdentityAllocation::set_extradata(const char* value) {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  extradata_->assign(value);
}
inline void AckIdentityAllocation::set_extradata(const char* value, size_t size) {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  extradata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckIdentityAllocation::mutable_extradata() {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  return extradata_;
}
inline ::std::string* AckIdentityAllocation::release_extradata() {
  clear_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = extradata_;
    extradata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AckIdentityAllocation::set_allocated_extradata(::std::string* extradata) {
  if (extradata_ != &::google::protobuf::internal::kEmptyString) {
    delete extradata_;
  }
  if (extradata) {
    set_has_extradata();
    extradata_ = extradata;
  } else {
    clear_has_extradata();
    extradata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PostHeartBeat

// required uint32 seqno = 1;
inline bool PostHeartBeat::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PostHeartBeat::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PostHeartBeat::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PostHeartBeat::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 PostHeartBeat::seqno() const {
  return seqno_;
}
inline void PostHeartBeat::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// optional string id = 2;
inline bool PostHeartBeat::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PostHeartBeat::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PostHeartBeat::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PostHeartBeat::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& PostHeartBeat::id() const {
  return *id_;
}
inline void PostHeartBeat::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void PostHeartBeat::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void PostHeartBeat::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PostHeartBeat::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* PostHeartBeat::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PostHeartBeat::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AckHeartBeat

// required uint32 seqno = 1;
inline bool AckHeartBeat::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckHeartBeat::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckHeartBeat::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckHeartBeat::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 AckHeartBeat::seqno() const {
  return seqno_;
}
inline void AckHeartBeat::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// -------------------------------------------------------------------

// RequestProgramUpgrade

// required uint32 seqno = 1;
inline bool RequestProgramUpgrade::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestProgramUpgrade::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestProgramUpgrade::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestProgramUpgrade::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 RequestProgramUpgrade::seqno() const {
  return seqno_;
}
inline void RequestProgramUpgrade::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required string hardware = 2;
inline bool RequestProgramUpgrade::has_hardware() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestProgramUpgrade::set_has_hardware() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestProgramUpgrade::clear_has_hardware() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestProgramUpgrade::clear_hardware() {
  if (hardware_ != &::google::protobuf::internal::kEmptyString) {
    hardware_->clear();
  }
  clear_has_hardware();
}
inline const ::std::string& RequestProgramUpgrade::hardware() const {
  return *hardware_;
}
inline void RequestProgramUpgrade::set_hardware(const ::std::string& value) {
  set_has_hardware();
  if (hardware_ == &::google::protobuf::internal::kEmptyString) {
    hardware_ = new ::std::string;
  }
  hardware_->assign(value);
}
inline void RequestProgramUpgrade::set_hardware(const char* value) {
  set_has_hardware();
  if (hardware_ == &::google::protobuf::internal::kEmptyString) {
    hardware_ = new ::std::string;
  }
  hardware_->assign(value);
}
inline void RequestProgramUpgrade::set_hardware(const char* value, size_t size) {
  set_has_hardware();
  if (hardware_ == &::google::protobuf::internal::kEmptyString) {
    hardware_ = new ::std::string;
  }
  hardware_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestProgramUpgrade::mutable_hardware() {
  set_has_hardware();
  if (hardware_ == &::google::protobuf::internal::kEmptyString) {
    hardware_ = new ::std::string;
  }
  return hardware_;
}
inline ::std::string* RequestProgramUpgrade::release_hardware() {
  clear_has_hardware();
  if (hardware_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hardware_;
    hardware_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestProgramUpgrade::set_allocated_hardware(::std::string* hardware) {
  if (hardware_ != &::google::protobuf::internal::kEmptyString) {
    delete hardware_;
  }
  if (hardware) {
    set_has_hardware();
    hardware_ = hardware;
  } else {
    clear_has_hardware();
    hardware_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string software = 3;
inline bool RequestProgramUpgrade::has_software() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestProgramUpgrade::set_has_software() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestProgramUpgrade::clear_has_software() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestProgramUpgrade::clear_software() {
  if (software_ != &::google::protobuf::internal::kEmptyString) {
    software_->clear();
  }
  clear_has_software();
}
inline const ::std::string& RequestProgramUpgrade::software() const {
  return *software_;
}
inline void RequestProgramUpgrade::set_software(const ::std::string& value) {
  set_has_software();
  if (software_ == &::google::protobuf::internal::kEmptyString) {
    software_ = new ::std::string;
  }
  software_->assign(value);
}
inline void RequestProgramUpgrade::set_software(const char* value) {
  set_has_software();
  if (software_ == &::google::protobuf::internal::kEmptyString) {
    software_ = new ::std::string;
  }
  software_->assign(value);
}
inline void RequestProgramUpgrade::set_software(const char* value, size_t size) {
  set_has_software();
  if (software_ == &::google::protobuf::internal::kEmptyString) {
    software_ = new ::std::string;
  }
  software_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestProgramUpgrade::mutable_software() {
  set_has_software();
  if (software_ == &::google::protobuf::internal::kEmptyString) {
    software_ = new ::std::string;
  }
  return software_;
}
inline ::std::string* RequestProgramUpgrade::release_software() {
  clear_has_software();
  if (software_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = software_;
    software_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestProgramUpgrade::set_allocated_software(::std::string* software) {
  if (software_ != &::google::protobuf::internal::kEmptyString) {
    delete software_;
  }
  if (software) {
    set_has_software();
    software_ = software;
  } else {
    clear_has_software();
    software_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string extradata = 4;
inline bool RequestProgramUpgrade::has_extradata() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestProgramUpgrade::set_has_extradata() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestProgramUpgrade::clear_has_extradata() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestProgramUpgrade::clear_extradata() {
  if (extradata_ != &::google::protobuf::internal::kEmptyString) {
    extradata_->clear();
  }
  clear_has_extradata();
}
inline const ::std::string& RequestProgramUpgrade::extradata() const {
  return *extradata_;
}
inline void RequestProgramUpgrade::set_extradata(const ::std::string& value) {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  extradata_->assign(value);
}
inline void RequestProgramUpgrade::set_extradata(const char* value) {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  extradata_->assign(value);
}
inline void RequestProgramUpgrade::set_extradata(const char* value, size_t size) {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  extradata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestProgramUpgrade::mutable_extradata() {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  return extradata_;
}
inline ::std::string* RequestProgramUpgrade::release_extradata() {
  clear_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = extradata_;
    extradata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestProgramUpgrade::set_allocated_extradata(::std::string* extradata) {
  if (extradata_ != &::google::protobuf::internal::kEmptyString) {
    delete extradata_;
  }
  if (extradata) {
    set_has_extradata();
    extradata_ = extradata;
  } else {
    clear_has_extradata();
    extradata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AckProgramUpgrade

// required uint32 seqno = 1;
inline bool AckProgramUpgrade::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckProgramUpgrade::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckProgramUpgrade::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckProgramUpgrade::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 AckProgramUpgrade::seqno() const {
  return seqno_;
}
inline void AckProgramUpgrade::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required int32 result = 2;
inline bool AckProgramUpgrade::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckProgramUpgrade::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckProgramUpgrade::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckProgramUpgrade::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 AckProgramUpgrade::result() const {
  return result_;
}
inline void AckProgramUpgrade::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// required string software = 3;
inline bool AckProgramUpgrade::has_software() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckProgramUpgrade::set_has_software() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckProgramUpgrade::clear_has_software() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckProgramUpgrade::clear_software() {
  if (software_ != &::google::protobuf::internal::kEmptyString) {
    software_->clear();
  }
  clear_has_software();
}
inline const ::std::string& AckProgramUpgrade::software() const {
  return *software_;
}
inline void AckProgramUpgrade::set_software(const ::std::string& value) {
  set_has_software();
  if (software_ == &::google::protobuf::internal::kEmptyString) {
    software_ = new ::std::string;
  }
  software_->assign(value);
}
inline void AckProgramUpgrade::set_software(const char* value) {
  set_has_software();
  if (software_ == &::google::protobuf::internal::kEmptyString) {
    software_ = new ::std::string;
  }
  software_->assign(value);
}
inline void AckProgramUpgrade::set_software(const char* value, size_t size) {
  set_has_software();
  if (software_ == &::google::protobuf::internal::kEmptyString) {
    software_ = new ::std::string;
  }
  software_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckProgramUpgrade::mutable_software() {
  set_has_software();
  if (software_ == &::google::protobuf::internal::kEmptyString) {
    software_ = new ::std::string;
  }
  return software_;
}
inline ::std::string* AckProgramUpgrade::release_software() {
  clear_has_software();
  if (software_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = software_;
    software_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AckProgramUpgrade::set_allocated_software(::std::string* software) {
  if (software_ != &::google::protobuf::internal::kEmptyString) {
    delete software_;
  }
  if (software) {
    set_has_software();
    software_ = software;
  } else {
    clear_has_software();
    software_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 length = 4;
inline bool AckProgramUpgrade::has_length() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AckProgramUpgrade::set_has_length() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AckProgramUpgrade::clear_has_length() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AckProgramUpgrade::clear_length() {
  length_ = 0;
  clear_has_length();
}
inline ::google::protobuf::int32 AckProgramUpgrade::length() const {
  return length_;
}
inline void AckProgramUpgrade::set_length(::google::protobuf::int32 value) {
  set_has_length();
  length_ = value;
}

// required bool forced = 5;
inline bool AckProgramUpgrade::has_forced() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AckProgramUpgrade::set_has_forced() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AckProgramUpgrade::clear_has_forced() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AckProgramUpgrade::clear_forced() {
  forced_ = false;
  clear_has_forced();
}
inline bool AckProgramUpgrade::forced() const {
  return forced_;
}
inline void AckProgramUpgrade::set_forced(bool value) {
  set_has_forced();
  forced_ = value;
}

// optional string extradata = 6;
inline bool AckProgramUpgrade::has_extradata() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AckProgramUpgrade::set_has_extradata() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AckProgramUpgrade::clear_has_extradata() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AckProgramUpgrade::clear_extradata() {
  if (extradata_ != &::google::protobuf::internal::kEmptyString) {
    extradata_->clear();
  }
  clear_has_extradata();
}
inline const ::std::string& AckProgramUpgrade::extradata() const {
  return *extradata_;
}
inline void AckProgramUpgrade::set_extradata(const ::std::string& value) {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  extradata_->assign(value);
}
inline void AckProgramUpgrade::set_extradata(const char* value) {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  extradata_->assign(value);
}
inline void AckProgramUpgrade::set_extradata(const char* value, size_t size) {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  extradata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckProgramUpgrade::mutable_extradata() {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  return extradata_;
}
inline ::std::string* AckProgramUpgrade::release_extradata() {
  clear_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = extradata_;
    extradata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AckProgramUpgrade::set_allocated_extradata(::std::string* extradata) {
  if (extradata_ != &::google::protobuf::internal::kEmptyString) {
    delete extradata_;
  }
  if (extradata) {
    set_has_extradata();
    extradata_ = extradata;
  } else {
    clear_has_extradata();
    extradata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RequestProgramDownload

// required uint32 seqno = 1;
inline bool RequestProgramDownload::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestProgramDownload::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestProgramDownload::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestProgramDownload::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 RequestProgramDownload::seqno() const {
  return seqno_;
}
inline void RequestProgramDownload::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required string software = 2;
inline bool RequestProgramDownload::has_software() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestProgramDownload::set_has_software() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestProgramDownload::clear_has_software() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestProgramDownload::clear_software() {
  if (software_ != &::google::protobuf::internal::kEmptyString) {
    software_->clear();
  }
  clear_has_software();
}
inline const ::std::string& RequestProgramDownload::software() const {
  return *software_;
}
inline void RequestProgramDownload::set_software(const ::std::string& value) {
  set_has_software();
  if (software_ == &::google::protobuf::internal::kEmptyString) {
    software_ = new ::std::string;
  }
  software_->assign(value);
}
inline void RequestProgramDownload::set_software(const char* value) {
  set_has_software();
  if (software_ == &::google::protobuf::internal::kEmptyString) {
    software_ = new ::std::string;
  }
  software_->assign(value);
}
inline void RequestProgramDownload::set_software(const char* value, size_t size) {
  set_has_software();
  if (software_ == &::google::protobuf::internal::kEmptyString) {
    software_ = new ::std::string;
  }
  software_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestProgramDownload::mutable_software() {
  set_has_software();
  if (software_ == &::google::protobuf::internal::kEmptyString) {
    software_ = new ::std::string;
  }
  return software_;
}
inline ::std::string* RequestProgramDownload::release_software() {
  clear_has_software();
  if (software_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = software_;
    software_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestProgramDownload::set_allocated_software(::std::string* software) {
  if (software_ != &::google::protobuf::internal::kEmptyString) {
    delete software_;
  }
  if (software) {
    set_has_software();
    software_ = software;
  } else {
    clear_has_software();
    software_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 offset = 3;
inline bool RequestProgramDownload::has_offset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestProgramDownload::set_has_offset() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestProgramDownload::clear_has_offset() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestProgramDownload::clear_offset() {
  offset_ = 0;
  clear_has_offset();
}
inline ::google::protobuf::int32 RequestProgramDownload::offset() const {
  return offset_;
}
inline void RequestProgramDownload::set_offset(::google::protobuf::int32 value) {
  set_has_offset();
  offset_ = value;
}

// required int32 length = 4;
inline bool RequestProgramDownload::has_length() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestProgramDownload::set_has_length() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestProgramDownload::clear_has_length() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestProgramDownload::clear_length() {
  length_ = 0;
  clear_has_length();
}
inline ::google::protobuf::int32 RequestProgramDownload::length() const {
  return length_;
}
inline void RequestProgramDownload::set_length(::google::protobuf::int32 value) {
  set_has_length();
  length_ = value;
}

// -------------------------------------------------------------------

// AckProgramDownload

// required uint32 seqno = 1;
inline bool AckProgramDownload::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckProgramDownload::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckProgramDownload::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckProgramDownload::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 AckProgramDownload::seqno() const {
  return seqno_;
}
inline void AckProgramDownload::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required int32 result = 2;
inline bool AckProgramDownload::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckProgramDownload::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckProgramDownload::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckProgramDownload::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 AckProgramDownload::result() const {
  return result_;
}
inline void AckProgramDownload::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// required string software = 3;
inline bool AckProgramDownload::has_software() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckProgramDownload::set_has_software() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckProgramDownload::clear_has_software() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckProgramDownload::clear_software() {
  if (software_ != &::google::protobuf::internal::kEmptyString) {
    software_->clear();
  }
  clear_has_software();
}
inline const ::std::string& AckProgramDownload::software() const {
  return *software_;
}
inline void AckProgramDownload::set_software(const ::std::string& value) {
  set_has_software();
  if (software_ == &::google::protobuf::internal::kEmptyString) {
    software_ = new ::std::string;
  }
  software_->assign(value);
}
inline void AckProgramDownload::set_software(const char* value) {
  set_has_software();
  if (software_ == &::google::protobuf::internal::kEmptyString) {
    software_ = new ::std::string;
  }
  software_->assign(value);
}
inline void AckProgramDownload::set_software(const char* value, size_t size) {
  set_has_software();
  if (software_ == &::google::protobuf::internal::kEmptyString) {
    software_ = new ::std::string;
  }
  software_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckProgramDownload::mutable_software() {
  set_has_software();
  if (software_ == &::google::protobuf::internal::kEmptyString) {
    software_ = new ::std::string;
  }
  return software_;
}
inline ::std::string* AckProgramDownload::release_software() {
  clear_has_software();
  if (software_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = software_;
    software_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AckProgramDownload::set_allocated_software(::std::string* software) {
  if (software_ != &::google::protobuf::internal::kEmptyString) {
    delete software_;
  }
  if (software) {
    set_has_software();
    software_ = software;
  } else {
    clear_has_software();
    software_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 offset = 4;
inline bool AckProgramDownload::has_offset() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AckProgramDownload::set_has_offset() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AckProgramDownload::clear_has_offset() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AckProgramDownload::clear_offset() {
  offset_ = 0;
  clear_has_offset();
}
inline ::google::protobuf::int32 AckProgramDownload::offset() const {
  return offset_;
}
inline void AckProgramDownload::set_offset(::google::protobuf::int32 value) {
  set_has_offset();
  offset_ = value;
}

// required int32 length = 5;
inline bool AckProgramDownload::has_length() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AckProgramDownload::set_has_length() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AckProgramDownload::clear_has_length() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AckProgramDownload::clear_length() {
  length_ = 0;
  clear_has_length();
}
inline ::google::protobuf::int32 AckProgramDownload::length() const {
  return length_;
}
inline void AckProgramDownload::set_length(::google::protobuf::int32 value) {
  set_has_length();
  length_ = value;
}

// optional bytes data = 6;
inline bool AckProgramDownload::has_data() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AckProgramDownload::set_has_data() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AckProgramDownload::clear_has_data() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AckProgramDownload::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& AckProgramDownload::data() const {
  return *data_;
}
inline void AckProgramDownload::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void AckProgramDownload::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void AckProgramDownload::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckProgramDownload::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* AckProgramDownload::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AckProgramDownload::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 crc32 = 7;
inline bool AckProgramDownload::has_crc32() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AckProgramDownload::set_has_crc32() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AckProgramDownload::clear_has_crc32() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AckProgramDownload::clear_crc32() {
  crc32_ = 0u;
  clear_has_crc32();
}
inline ::google::protobuf::uint32 AckProgramDownload::crc32() const {
  return crc32_;
}
inline void AckProgramDownload::set_crc32(::google::protobuf::uint32 value) {
  set_has_crc32();
  crc32_ = value;
}

// -------------------------------------------------------------------

// ParameterDescription

// required string name = 1;
inline bool ParameterDescription::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ParameterDescription::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ParameterDescription::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ParameterDescription::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ParameterDescription::name() const {
  return *name_;
}
inline void ParameterDescription::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ParameterDescription::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ParameterDescription::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ParameterDescription::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ParameterDescription::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ParameterDescription::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bool readonly = 2;
inline bool ParameterDescription::has_readonly() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ParameterDescription::set_has_readonly() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ParameterDescription::clear_has_readonly() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ParameterDescription::clear_readonly() {
  readonly_ = false;
  clear_has_readonly();
}
inline bool ParameterDescription::readonly() const {
  return readonly_;
}
inline void ParameterDescription::set_readonly(bool value) {
  set_has_readonly();
  readonly_ = value;
}

// required uint32 type = 3;
inline bool ParameterDescription::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ParameterDescription::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ParameterDescription::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ParameterDescription::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 ParameterDescription::type() const {
  return type_;
}
inline void ParameterDescription::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// required string value = 4;
inline bool ParameterDescription::has_value() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ParameterDescription::set_has_value() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ParameterDescription::clear_has_value() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ParameterDescription::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& ParameterDescription::value() const {
  return *value_;
}
inline void ParameterDescription::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void ParameterDescription::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void ParameterDescription::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ParameterDescription::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* ParameterDescription::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ParameterDescription::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// QueryParameters

// required uint32 seqno = 1;
inline bool QueryParameters::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QueryParameters::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QueryParameters::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QueryParameters::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 QueryParameters::seqno() const {
  return seqno_;
}
inline void QueryParameters::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required string id = 2;
inline bool QueryParameters::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QueryParameters::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QueryParameters::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QueryParameters::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& QueryParameters::id() const {
  return *id_;
}
inline void QueryParameters::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void QueryParameters::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void QueryParameters::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QueryParameters::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* QueryParameters::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void QueryParameters::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AckQueryParameters

// required uint32 seqno = 1;
inline bool AckQueryParameters::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckQueryParameters::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckQueryParameters::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckQueryParameters::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 AckQueryParameters::seqno() const {
  return seqno_;
}
inline void AckQueryParameters::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required string id = 2;
inline bool AckQueryParameters::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckQueryParameters::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckQueryParameters::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckQueryParameters::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& AckQueryParameters::id() const {
  return *id_;
}
inline void AckQueryParameters::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void AckQueryParameters::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void AckQueryParameters::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckQueryParameters::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* AckQueryParameters::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AckQueryParameters::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 result = 3;
inline bool AckQueryParameters::has_result() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckQueryParameters::set_has_result() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckQueryParameters::clear_has_result() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckQueryParameters::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 AckQueryParameters::result() const {
  return result_;
}
inline void AckQueryParameters::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// repeated .das.proto.ParameterDescription pd = 4;
inline int AckQueryParameters::pd_size() const {
  return pd_.size();
}
inline void AckQueryParameters::clear_pd() {
  pd_.Clear();
}
inline const ::das::proto::ParameterDescription& AckQueryParameters::pd(int index) const {
  return pd_.Get(index);
}
inline ::das::proto::ParameterDescription* AckQueryParameters::mutable_pd(int index) {
  return pd_.Mutable(index);
}
inline ::das::proto::ParameterDescription* AckQueryParameters::add_pd() {
  return pd_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::das::proto::ParameterDescription >&
AckQueryParameters::pd() const {
  return pd_;
}
inline ::google::protobuf::RepeatedPtrField< ::das::proto::ParameterDescription >*
AckQueryParameters::mutable_pd() {
  return &pd_;
}

// -------------------------------------------------------------------

// ConfigureParameters

// required uint32 seqno = 1;
inline bool ConfigureParameters::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConfigureParameters::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConfigureParameters::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConfigureParameters::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 ConfigureParameters::seqno() const {
  return seqno_;
}
inline void ConfigureParameters::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required string id = 2;
inline bool ConfigureParameters::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConfigureParameters::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConfigureParameters::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConfigureParameters::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& ConfigureParameters::id() const {
  return *id_;
}
inline void ConfigureParameters::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void ConfigureParameters::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void ConfigureParameters::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConfigureParameters::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* ConfigureParameters::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ConfigureParameters::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .das.proto.ParameterDescription pd = 3;
inline int ConfigureParameters::pd_size() const {
  return pd_.size();
}
inline void ConfigureParameters::clear_pd() {
  pd_.Clear();
}
inline const ::das::proto::ParameterDescription& ConfigureParameters::pd(int index) const {
  return pd_.Get(index);
}
inline ::das::proto::ParameterDescription* ConfigureParameters::mutable_pd(int index) {
  return pd_.Mutable(index);
}
inline ::das::proto::ParameterDescription* ConfigureParameters::add_pd() {
  return pd_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::das::proto::ParameterDescription >&
ConfigureParameters::pd() const {
  return pd_;
}
inline ::google::protobuf::RepeatedPtrField< ::das::proto::ParameterDescription >*
ConfigureParameters::mutable_pd() {
  return &pd_;
}

// -------------------------------------------------------------------

// AckConfigurParameters

// required uint32 seqno = 1;
inline bool AckConfigurParameters::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckConfigurParameters::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckConfigurParameters::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckConfigurParameters::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 AckConfigurParameters::seqno() const {
  return seqno_;
}
inline void AckConfigurParameters::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required string id = 2;
inline bool AckConfigurParameters::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckConfigurParameters::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckConfigurParameters::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckConfigurParameters::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& AckConfigurParameters::id() const {
  return *id_;
}
inline void AckConfigurParameters::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void AckConfigurParameters::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void AckConfigurParameters::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckConfigurParameters::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* AckConfigurParameters::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AckConfigurParameters::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 result = 3;
inline bool AckConfigurParameters::has_result() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckConfigurParameters::set_has_result() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckConfigurParameters::clear_has_result() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckConfigurParameters::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 AckConfigurParameters::result() const {
  return result_;
}
inline void AckConfigurParameters::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// Coordinate

// required int32 longitude = 1;
inline bool Coordinate::has_longitude() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Coordinate::set_has_longitude() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Coordinate::clear_has_longitude() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Coordinate::clear_longitude() {
  longitude_ = 0;
  clear_has_longitude();
}
inline ::google::protobuf::int32 Coordinate::longitude() const {
  return longitude_;
}
inline void Coordinate::set_longitude(::google::protobuf::int32 value) {
  set_has_longitude();
  longitude_ = value;
}

// required int32 latitude = 2;
inline bool Coordinate::has_latitude() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Coordinate::set_has_latitude() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Coordinate::clear_has_latitude() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Coordinate::clear_latitude() {
  latitude_ = 0;
  clear_has_latitude();
}
inline ::google::protobuf::int32 Coordinate::latitude() const {
  return latitude_;
}
inline void Coordinate::set_latitude(::google::protobuf::int32 value) {
  set_has_latitude();
  latitude_ = value;
}

// optional int32 altitude = 3;
inline bool Coordinate::has_altitude() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Coordinate::set_has_altitude() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Coordinate::clear_has_altitude() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Coordinate::clear_altitude() {
  altitude_ = 0;
  clear_has_altitude();
}
inline ::google::protobuf::int32 Coordinate::altitude() const {
  return altitude_;
}
inline void Coordinate::set_altitude(::google::protobuf::int32 value) {
  set_has_altitude();
  altitude_ = value;
}

// -------------------------------------------------------------------

// OperationSnapshot

// required string devid = 1;
inline bool OperationSnapshot::has_devid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OperationSnapshot::set_has_devid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OperationSnapshot::clear_has_devid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OperationSnapshot::clear_devid() {
  if (devid_ != &::google::protobuf::internal::kEmptyString) {
    devid_->clear();
  }
  clear_has_devid();
}
inline const ::std::string& OperationSnapshot::devid() const {
  return *devid_;
}
inline void OperationSnapshot::set_devid(const ::std::string& value) {
  set_has_devid();
  if (devid_ == &::google::protobuf::internal::kEmptyString) {
    devid_ = new ::std::string;
  }
  devid_->assign(value);
}
inline void OperationSnapshot::set_devid(const char* value) {
  set_has_devid();
  if (devid_ == &::google::protobuf::internal::kEmptyString) {
    devid_ = new ::std::string;
  }
  devid_->assign(value);
}
inline void OperationSnapshot::set_devid(const char* value, size_t size) {
  set_has_devid();
  if (devid_ == &::google::protobuf::internal::kEmptyString) {
    devid_ = new ::std::string;
  }
  devid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OperationSnapshot::mutable_devid() {
  set_has_devid();
  if (devid_ == &::google::protobuf::internal::kEmptyString) {
    devid_ = new ::std::string;
  }
  return devid_;
}
inline ::std::string* OperationSnapshot::release_devid() {
  clear_has_devid();
  if (devid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = devid_;
    devid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OperationSnapshot::set_allocated_devid(::std::string* devid) {
  if (devid_ != &::google::protobuf::internal::kEmptyString) {
    delete devid_;
  }
  if (devid) {
    set_has_devid();
    devid_ = devid;
  } else {
    clear_has_devid();
    devid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint64 timestamp = 2;
inline bool OperationSnapshot::has_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OperationSnapshot::set_has_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OperationSnapshot::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OperationSnapshot::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 OperationSnapshot::timestamp() const {
  return timestamp_;
}
inline void OperationSnapshot::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// optional .das.proto.Coordinate pos = 3;
inline bool OperationSnapshot::has_pos() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OperationSnapshot::set_has_pos() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OperationSnapshot::clear_has_pos() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OperationSnapshot::clear_pos() {
  if (pos_ != NULL) pos_->::das::proto::Coordinate::Clear();
  clear_has_pos();
}
inline const ::das::proto::Coordinate& OperationSnapshot::pos() const {
  return pos_ != NULL ? *pos_ : *default_instance_->pos_;
}
inline ::das::proto::Coordinate* OperationSnapshot::mutable_pos() {
  set_has_pos();
  if (pos_ == NULL) pos_ = new ::das::proto::Coordinate;
  return pos_;
}
inline ::das::proto::Coordinate* OperationSnapshot::release_pos() {
  clear_has_pos();
  ::das::proto::Coordinate* temp = pos_;
  pos_ = NULL;
  return temp;
}
inline void OperationSnapshot::set_allocated_pos(::das::proto::Coordinate* pos) {
  delete pos_;
  pos_ = pos;
  if (pos) {
    set_has_pos();
  } else {
    clear_has_pos();
  }
}

// optional int32 size = 4;
inline bool OperationSnapshot::has_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OperationSnapshot::set_has_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OperationSnapshot::clear_has_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OperationSnapshot::clear_size() {
  size_ = 0;
  clear_has_size();
}
inline ::google::protobuf::int32 OperationSnapshot::size() const {
  return size_;
}
inline void OperationSnapshot::set_size(::google::protobuf::int32 value) {
  set_has_size();
  size_ = value;
}

// required bytes pic = 5;
inline bool OperationSnapshot::has_pic() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OperationSnapshot::set_has_pic() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OperationSnapshot::clear_has_pic() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OperationSnapshot::clear_pic() {
  if (pic_ != &::google::protobuf::internal::kEmptyString) {
    pic_->clear();
  }
  clear_has_pic();
}
inline const ::std::string& OperationSnapshot::pic() const {
  return *pic_;
}
inline void OperationSnapshot::set_pic(const ::std::string& value) {
  set_has_pic();
  if (pic_ == &::google::protobuf::internal::kEmptyString) {
    pic_ = new ::std::string;
  }
  pic_->assign(value);
}
inline void OperationSnapshot::set_pic(const char* value) {
  set_has_pic();
  if (pic_ == &::google::protobuf::internal::kEmptyString) {
    pic_ = new ::std::string;
  }
  pic_->assign(value);
}
inline void OperationSnapshot::set_pic(const void* value, size_t size) {
  set_has_pic();
  if (pic_ == &::google::protobuf::internal::kEmptyString) {
    pic_ = new ::std::string;
  }
  pic_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OperationSnapshot::mutable_pic() {
  set_has_pic();
  if (pic_ == &::google::protobuf::internal::kEmptyString) {
    pic_ = new ::std::string;
  }
  return pic_;
}
inline ::std::string* OperationSnapshot::release_pic() {
  clear_has_pic();
  if (pic_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pic_;
    pic_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OperationSnapshot::set_allocated_pic(::std::string* pic) {
  if (pic_ != &::google::protobuf::internal::kEmptyString) {
    delete pic_;
  }
  if (pic) {
    set_has_pic();
    pic_ = pic;
  } else {
    clear_has_pic();
    pic_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PostOperationSnapshot

// required uint32 seqno = 1;
inline bool PostOperationSnapshot::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PostOperationSnapshot::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PostOperationSnapshot::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PostOperationSnapshot::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 PostOperationSnapshot::seqno() const {
  return seqno_;
}
inline void PostOperationSnapshot::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required .das.proto.OperationSnapshot os = 2;
inline bool PostOperationSnapshot::has_os() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PostOperationSnapshot::set_has_os() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PostOperationSnapshot::clear_has_os() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PostOperationSnapshot::clear_os() {
  if (os_ != NULL) os_->::das::proto::OperationSnapshot::Clear();
  clear_has_os();
}
inline const ::das::proto::OperationSnapshot& PostOperationSnapshot::os() const {
  return os_ != NULL ? *os_ : *default_instance_->os_;
}
inline ::das::proto::OperationSnapshot* PostOperationSnapshot::mutable_os() {
  set_has_os();
  if (os_ == NULL) os_ = new ::das::proto::OperationSnapshot;
  return os_;
}
inline ::das::proto::OperationSnapshot* PostOperationSnapshot::release_os() {
  clear_has_os();
  ::das::proto::OperationSnapshot* temp = os_;
  os_ = NULL;
  return temp;
}
inline void PostOperationSnapshot::set_allocated_os(::das::proto::OperationSnapshot* os) {
  delete os_;
  os_ = os;
  if (os) {
    set_has_os();
  } else {
    clear_has_os();
  }
}

// -------------------------------------------------------------------

// AckPostOperationSnapshot

// required uint32 seqno = 1;
inline bool AckPostOperationSnapshot::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckPostOperationSnapshot::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckPostOperationSnapshot::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckPostOperationSnapshot::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 AckPostOperationSnapshot::seqno() const {
  return seqno_;
}
inline void AckPostOperationSnapshot::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required int32 result = 2;
inline bool AckPostOperationSnapshot::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckPostOperationSnapshot::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckPostOperationSnapshot::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckPostOperationSnapshot::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 AckPostOperationSnapshot::result() const {
  return result_;
}
inline void AckPostOperationSnapshot::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// RequestPositionAuthentication

// required uint32 seqno = 1;
inline bool RequestPositionAuthentication::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestPositionAuthentication::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestPositionAuthentication::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestPositionAuthentication::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 RequestPositionAuthentication::seqno() const {
  return seqno_;
}
inline void RequestPositionAuthentication::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required string devid = 2;
inline bool RequestPositionAuthentication::has_devid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestPositionAuthentication::set_has_devid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestPositionAuthentication::clear_has_devid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestPositionAuthentication::clear_devid() {
  if (devid_ != &::google::protobuf::internal::kEmptyString) {
    devid_->clear();
  }
  clear_has_devid();
}
inline const ::std::string& RequestPositionAuthentication::devid() const {
  return *devid_;
}
inline void RequestPositionAuthentication::set_devid(const ::std::string& value) {
  set_has_devid();
  if (devid_ == &::google::protobuf::internal::kEmptyString) {
    devid_ = new ::std::string;
  }
  devid_->assign(value);
}
inline void RequestPositionAuthentication::set_devid(const char* value) {
  set_has_devid();
  if (devid_ == &::google::protobuf::internal::kEmptyString) {
    devid_ = new ::std::string;
  }
  devid_->assign(value);
}
inline void RequestPositionAuthentication::set_devid(const char* value, size_t size) {
  set_has_devid();
  if (devid_ == &::google::protobuf::internal::kEmptyString) {
    devid_ = new ::std::string;
  }
  devid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestPositionAuthentication::mutable_devid() {
  set_has_devid();
  if (devid_ == &::google::protobuf::internal::kEmptyString) {
    devid_ = new ::std::string;
  }
  return devid_;
}
inline ::std::string* RequestPositionAuthentication::release_devid() {
  clear_has_devid();
  if (devid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = devid_;
    devid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestPositionAuthentication::set_allocated_devid(::std::string* devid) {
  if (devid_ != &::google::protobuf::internal::kEmptyString) {
    delete devid_;
  }
  if (devid) {
    set_has_devid();
    devid_ = devid;
  } else {
    clear_has_devid();
    devid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .das.proto.GpsInformation pos = 3;
inline bool RequestPositionAuthentication::has_pos() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestPositionAuthentication::set_has_pos() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestPositionAuthentication::clear_has_pos() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestPositionAuthentication::clear_pos() {
  if (pos_ != NULL) pos_->::das::proto::GpsInformation::Clear();
  clear_has_pos();
}
inline const ::das::proto::GpsInformation& RequestPositionAuthentication::pos() const {
  return pos_ != NULL ? *pos_ : *default_instance_->pos_;
}
inline ::das::proto::GpsInformation* RequestPositionAuthentication::mutable_pos() {
  set_has_pos();
  if (pos_ == NULL) pos_ = new ::das::proto::GpsInformation;
  return pos_;
}
inline ::das::proto::GpsInformation* RequestPositionAuthentication::release_pos() {
  clear_has_pos();
  ::das::proto::GpsInformation* temp = pos_;
  pos_ = NULL;
  return temp;
}
inline void RequestPositionAuthentication::set_allocated_pos(::das::proto::GpsInformation* pos) {
  delete pos_;
  pos_ = pos;
  if (pos) {
    set_has_pos();
  } else {
    clear_has_pos();
  }
}

// -------------------------------------------------------------------

// AckPositionAuthentication

// required uint32 seqno = 1;
inline bool AckPositionAuthentication::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckPositionAuthentication::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckPositionAuthentication::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckPositionAuthentication::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 AckPositionAuthentication::seqno() const {
  return seqno_;
}
inline void AckPositionAuthentication::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required int32 result = 2;
inline bool AckPositionAuthentication::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckPositionAuthentication::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckPositionAuthentication::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckPositionAuthentication::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 AckPositionAuthentication::result() const {
  return result_;
}
inline void AckPositionAuthentication::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// ReportDeviceException

// required uint32 seqno = 1;
inline bool ReportDeviceException::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReportDeviceException::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReportDeviceException::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReportDeviceException::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 ReportDeviceException::seqno() const {
  return seqno_;
}
inline void ReportDeviceException::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required string id = 2;
inline bool ReportDeviceException::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReportDeviceException::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReportDeviceException::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReportDeviceException::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& ReportDeviceException::id() const {
  return *id_;
}
inline void ReportDeviceException::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void ReportDeviceException::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void ReportDeviceException::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReportDeviceException::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* ReportDeviceException::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReportDeviceException::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string desc = 3;
inline int ReportDeviceException::desc_size() const {
  return desc_.size();
}
inline void ReportDeviceException::clear_desc() {
  desc_.Clear();
}
inline const ::std::string& ReportDeviceException::desc(int index) const {
  return desc_.Get(index);
}
inline ::std::string* ReportDeviceException::mutable_desc(int index) {
  return desc_.Mutable(index);
}
inline void ReportDeviceException::set_desc(int index, const ::std::string& value) {
  desc_.Mutable(index)->assign(value);
}
inline void ReportDeviceException::set_desc(int index, const char* value) {
  desc_.Mutable(index)->assign(value);
}
inline void ReportDeviceException::set_desc(int index, const char* value, size_t size) {
  desc_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReportDeviceException::add_desc() {
  return desc_.Add();
}
inline void ReportDeviceException::add_desc(const ::std::string& value) {
  desc_.Add()->assign(value);
}
inline void ReportDeviceException::add_desc(const char* value) {
  desc_.Add()->assign(value);
}
inline void ReportDeviceException::add_desc(const char* value, size_t size) {
  desc_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ReportDeviceException::desc() const {
  return desc_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ReportDeviceException::mutable_desc() {
  return &desc_;
}

// -------------------------------------------------------------------

// AckReportDeviceException

// required uint32 seqno = 1;
inline bool AckReportDeviceException::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckReportDeviceException::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckReportDeviceException::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckReportDeviceException::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 AckReportDeviceException::seqno() const {
  return seqno_;
}
inline void AckReportDeviceException::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required int32 result = 2;
inline bool AckReportDeviceException::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckReportDeviceException::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckReportDeviceException::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckReportDeviceException::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 AckReportDeviceException::result() const {
  return result_;
}
inline void AckReportDeviceException::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// RequestGVIdentityAuthentication

// required uint32 seqno = 1;
inline bool RequestGVIdentityAuthentication::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestGVIdentityAuthentication::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestGVIdentityAuthentication::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestGVIdentityAuthentication::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 RequestGVIdentityAuthentication::seqno() const {
  return seqno_;
}
inline void RequestGVIdentityAuthentication::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required string userid = 2;
inline bool RequestGVIdentityAuthentication::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestGVIdentityAuthentication::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestGVIdentityAuthentication::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestGVIdentityAuthentication::clear_userid() {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    userid_->clear();
  }
  clear_has_userid();
}
inline const ::std::string& RequestGVIdentityAuthentication::userid() const {
  return *userid_;
}
inline void RequestGVIdentityAuthentication::set_userid(const ::std::string& value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void RequestGVIdentityAuthentication::set_userid(const char* value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void RequestGVIdentityAuthentication::set_userid(const char* value, size_t size) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestGVIdentityAuthentication::mutable_userid() {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  return userid_;
}
inline ::std::string* RequestGVIdentityAuthentication::release_userid() {
  clear_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userid_;
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestGVIdentityAuthentication::set_allocated_userid(::std::string* userid) {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    delete userid_;
  }
  if (userid) {
    set_has_userid();
    userid_ = userid;
  } else {
    clear_has_userid();
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string password = 3;
inline bool RequestGVIdentityAuthentication::has_password() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestGVIdentityAuthentication::set_has_password() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestGVIdentityAuthentication::clear_has_password() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestGVIdentityAuthentication::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& RequestGVIdentityAuthentication::password() const {
  return *password_;
}
inline void RequestGVIdentityAuthentication::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void RequestGVIdentityAuthentication::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void RequestGVIdentityAuthentication::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestGVIdentityAuthentication::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* RequestGVIdentityAuthentication::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestGVIdentityAuthentication::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string extradata = 4;
inline bool RequestGVIdentityAuthentication::has_extradata() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestGVIdentityAuthentication::set_has_extradata() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestGVIdentityAuthentication::clear_has_extradata() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestGVIdentityAuthentication::clear_extradata() {
  if (extradata_ != &::google::protobuf::internal::kEmptyString) {
    extradata_->clear();
  }
  clear_has_extradata();
}
inline const ::std::string& RequestGVIdentityAuthentication::extradata() const {
  return *extradata_;
}
inline void RequestGVIdentityAuthentication::set_extradata(const ::std::string& value) {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  extradata_->assign(value);
}
inline void RequestGVIdentityAuthentication::set_extradata(const char* value) {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  extradata_->assign(value);
}
inline void RequestGVIdentityAuthentication::set_extradata(const char* value, size_t size) {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  extradata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestGVIdentityAuthentication::mutable_extradata() {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  return extradata_;
}
inline ::std::string* RequestGVIdentityAuthentication::release_extradata() {
  clear_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = extradata_;
    extradata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestGVIdentityAuthentication::set_allocated_extradata(::std::string* extradata) {
  if (extradata_ != &::google::protobuf::internal::kEmptyString) {
    delete extradata_;
  }
  if (extradata) {
    set_has_extradata();
    extradata_ = extradata;
  } else {
    clear_has_extradata();
    extradata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AckGVIdentityAuthentication

// required uint32 seqno = 1;
inline bool AckGVIdentityAuthentication::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckGVIdentityAuthentication::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckGVIdentityAuthentication::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckGVIdentityAuthentication::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 AckGVIdentityAuthentication::seqno() const {
  return seqno_;
}
inline void AckGVIdentityAuthentication::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required int32 result = 2;
inline bool AckGVIdentityAuthentication::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckGVIdentityAuthentication::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckGVIdentityAuthentication::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckGVIdentityAuthentication::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 AckGVIdentityAuthentication::result() const {
  return result_;
}
inline void AckGVIdentityAuthentication::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional string extradata = 3;
inline bool AckGVIdentityAuthentication::has_extradata() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckGVIdentityAuthentication::set_has_extradata() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckGVIdentityAuthentication::clear_has_extradata() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckGVIdentityAuthentication::clear_extradata() {
  if (extradata_ != &::google::protobuf::internal::kEmptyString) {
    extradata_->clear();
  }
  clear_has_extradata();
}
inline const ::std::string& AckGVIdentityAuthentication::extradata() const {
  return *extradata_;
}
inline void AckGVIdentityAuthentication::set_extradata(const ::std::string& value) {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  extradata_->assign(value);
}
inline void AckGVIdentityAuthentication::set_extradata(const char* value) {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  extradata_->assign(value);
}
inline void AckGVIdentityAuthentication::set_extradata(const char* value, size_t size) {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  extradata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckGVIdentityAuthentication::mutable_extradata() {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  return extradata_;
}
inline ::std::string* AckGVIdentityAuthentication::release_extradata() {
  clear_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = extradata_;
    extradata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AckGVIdentityAuthentication::set_allocated_extradata(::std::string* extradata) {
  if (extradata_ != &::google::protobuf::internal::kEmptyString) {
    delete extradata_;
  }
  if (extradata) {
    set_has_extradata();
    extradata_ = extradata;
  } else {
    clear_has_extradata();
    extradata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RequestIVIdentityAuthentication

// required uint32 seqno = 1;
inline bool RequestIVIdentityAuthentication::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestIVIdentityAuthentication::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestIVIdentityAuthentication::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestIVIdentityAuthentication::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 RequestIVIdentityAuthentication::seqno() const {
  return seqno_;
}
inline void RequestIVIdentityAuthentication::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required string userid = 2;
inline bool RequestIVIdentityAuthentication::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestIVIdentityAuthentication::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestIVIdentityAuthentication::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestIVIdentityAuthentication::clear_userid() {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    userid_->clear();
  }
  clear_has_userid();
}
inline const ::std::string& RequestIVIdentityAuthentication::userid() const {
  return *userid_;
}
inline void RequestIVIdentityAuthentication::set_userid(const ::std::string& value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void RequestIVIdentityAuthentication::set_userid(const char* value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void RequestIVIdentityAuthentication::set_userid(const char* value, size_t size) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestIVIdentityAuthentication::mutable_userid() {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  return userid_;
}
inline ::std::string* RequestIVIdentityAuthentication::release_userid() {
  clear_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userid_;
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestIVIdentityAuthentication::set_allocated_userid(::std::string* userid) {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    delete userid_;
  }
  if (userid) {
    set_has_userid();
    userid_ = userid;
  } else {
    clear_has_userid();
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string password = 3;
inline bool RequestIVIdentityAuthentication::has_password() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestIVIdentityAuthentication::set_has_password() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestIVIdentityAuthentication::clear_has_password() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestIVIdentityAuthentication::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& RequestIVIdentityAuthentication::password() const {
  return *password_;
}
inline void RequestIVIdentityAuthentication::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void RequestIVIdentityAuthentication::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void RequestIVIdentityAuthentication::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestIVIdentityAuthentication::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* RequestIVIdentityAuthentication::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestIVIdentityAuthentication::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string extradata = 4;
inline bool RequestIVIdentityAuthentication::has_extradata() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestIVIdentityAuthentication::set_has_extradata() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestIVIdentityAuthentication::clear_has_extradata() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestIVIdentityAuthentication::clear_extradata() {
  if (extradata_ != &::google::protobuf::internal::kEmptyString) {
    extradata_->clear();
  }
  clear_has_extradata();
}
inline const ::std::string& RequestIVIdentityAuthentication::extradata() const {
  return *extradata_;
}
inline void RequestIVIdentityAuthentication::set_extradata(const ::std::string& value) {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  extradata_->assign(value);
}
inline void RequestIVIdentityAuthentication::set_extradata(const char* value) {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  extradata_->assign(value);
}
inline void RequestIVIdentityAuthentication::set_extradata(const char* value, size_t size) {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  extradata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestIVIdentityAuthentication::mutable_extradata() {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  return extradata_;
}
inline ::std::string* RequestIVIdentityAuthentication::release_extradata() {
  clear_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = extradata_;
    extradata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestIVIdentityAuthentication::set_allocated_extradata(::std::string* extradata) {
  if (extradata_ != &::google::protobuf::internal::kEmptyString) {
    delete extradata_;
  }
  if (extradata) {
    set_has_extradata();
    extradata_ = extradata;
  } else {
    clear_has_extradata();
    extradata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AckIVIdentityAuthentication

// required uint32 seqno = 1;
inline bool AckIVIdentityAuthentication::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckIVIdentityAuthentication::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckIVIdentityAuthentication::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckIVIdentityAuthentication::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 AckIVIdentityAuthentication::seqno() const {
  return seqno_;
}
inline void AckIVIdentityAuthentication::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required int32 result = 2;
inline bool AckIVIdentityAuthentication::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckIVIdentityAuthentication::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckIVIdentityAuthentication::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckIVIdentityAuthentication::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 AckIVIdentityAuthentication::result() const {
  return result_;
}
inline void AckIVIdentityAuthentication::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional string extradata = 3;
inline bool AckIVIdentityAuthentication::has_extradata() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckIVIdentityAuthentication::set_has_extradata() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckIVIdentityAuthentication::clear_has_extradata() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckIVIdentityAuthentication::clear_extradata() {
  if (extradata_ != &::google::protobuf::internal::kEmptyString) {
    extradata_->clear();
  }
  clear_has_extradata();
}
inline const ::std::string& AckIVIdentityAuthentication::extradata() const {
  return *extradata_;
}
inline void AckIVIdentityAuthentication::set_extradata(const ::std::string& value) {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  extradata_->assign(value);
}
inline void AckIVIdentityAuthentication::set_extradata(const char* value) {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  extradata_->assign(value);
}
inline void AckIVIdentityAuthentication::set_extradata(const char* value, size_t size) {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  extradata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckIVIdentityAuthentication::mutable_extradata() {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  return extradata_;
}
inline ::std::string* AckIVIdentityAuthentication::release_extradata() {
  clear_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = extradata_;
    extradata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AckIVIdentityAuthentication::set_allocated_extradata(::std::string* extradata) {
  if (extradata_ != &::google::protobuf::internal::kEmptyString) {
    delete extradata_;
  }
  if (extradata) {
    set_has_extradata();
    extradata_ = extradata;
  } else {
    clear_has_extradata();
    extradata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UpdateDeviceList

// required uint32 seqno = 1;
inline bool UpdateDeviceList::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateDeviceList::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateDeviceList::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateDeviceList::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 UpdateDeviceList::seqno() const {
  return seqno_;
}
inline void UpdateDeviceList::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required uint32 operation = 2;
inline bool UpdateDeviceList::has_operation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdateDeviceList::set_has_operation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdateDeviceList::clear_has_operation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdateDeviceList::clear_operation() {
  operation_ = 0u;
  clear_has_operation();
}
inline ::google::protobuf::uint32 UpdateDeviceList::operation() const {
  return operation_;
}
inline void UpdateDeviceList::set_operation(::google::protobuf::uint32 value) {
  set_has_operation();
  operation_ = value;
}

// repeated string id = 3;
inline int UpdateDeviceList::id_size() const {
  return id_.size();
}
inline void UpdateDeviceList::clear_id() {
  id_.Clear();
}
inline const ::std::string& UpdateDeviceList::id(int index) const {
  return id_.Get(index);
}
inline ::std::string* UpdateDeviceList::mutable_id(int index) {
  return id_.Mutable(index);
}
inline void UpdateDeviceList::set_id(int index, const ::std::string& value) {
  id_.Mutable(index)->assign(value);
}
inline void UpdateDeviceList::set_id(int index, const char* value) {
  id_.Mutable(index)->assign(value);
}
inline void UpdateDeviceList::set_id(int index, const char* value, size_t size) {
  id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateDeviceList::add_id() {
  return id_.Add();
}
inline void UpdateDeviceList::add_id(const ::std::string& value) {
  id_.Add()->assign(value);
}
inline void UpdateDeviceList::add_id(const char* value) {
  id_.Add()->assign(value);
}
inline void UpdateDeviceList::add_id(const char* value, size_t size) {
  id_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
UpdateDeviceList::id() const {
  return id_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
UpdateDeviceList::mutable_id() {
  return &id_;
}

// -------------------------------------------------------------------

// AckUpdateDeviceList

// required uint32 seqno = 1;
inline bool AckUpdateDeviceList::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckUpdateDeviceList::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckUpdateDeviceList::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckUpdateDeviceList::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 AckUpdateDeviceList::seqno() const {
  return seqno_;
}
inline void AckUpdateDeviceList::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required int32 result = 2;
inline bool AckUpdateDeviceList::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckUpdateDeviceList::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckUpdateDeviceList::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckUpdateDeviceList::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 AckUpdateDeviceList::result() const {
  return result_;
}
inline void AckUpdateDeviceList::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// SyncDeviceList

// required uint32 seqno = 1;
inline bool SyncDeviceList::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SyncDeviceList::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SyncDeviceList::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SyncDeviceList::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 SyncDeviceList::seqno() const {
  return seqno_;
}
inline void SyncDeviceList::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// -------------------------------------------------------------------

// AckSyncDeviceList

// required uint32 seqno = 1;
inline bool AckSyncDeviceList::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckSyncDeviceList::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckSyncDeviceList::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckSyncDeviceList::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 AckSyncDeviceList::seqno() const {
  return seqno_;
}
inline void AckSyncDeviceList::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required int32 result = 2;
inline bool AckSyncDeviceList::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckSyncDeviceList::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckSyncDeviceList::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckSyncDeviceList::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 AckSyncDeviceList::result() const {
  return result_;
}
inline void AckSyncDeviceList::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// repeated string id = 3;
inline int AckSyncDeviceList::id_size() const {
  return id_.size();
}
inline void AckSyncDeviceList::clear_id() {
  id_.Clear();
}
inline const ::std::string& AckSyncDeviceList::id(int index) const {
  return id_.Get(index);
}
inline ::std::string* AckSyncDeviceList::mutable_id(int index) {
  return id_.Mutable(index);
}
inline void AckSyncDeviceList::set_id(int index, const ::std::string& value) {
  id_.Mutable(index)->assign(value);
}
inline void AckSyncDeviceList::set_id(int index, const char* value) {
  id_.Mutable(index)->assign(value);
}
inline void AckSyncDeviceList::set_id(int index, const char* value, size_t size) {
  id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckSyncDeviceList::add_id() {
  return id_.Add();
}
inline void AckSyncDeviceList::add_id(const ::std::string& value) {
  id_.Add()->assign(value);
}
inline void AckSyncDeviceList::add_id(const char* value) {
  id_.Add()->assign(value);
}
inline void AckSyncDeviceList::add_id(const char* value, size_t size) {
  id_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
AckSyncDeviceList::id() const {
  return id_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
AckSyncDeviceList::mutable_id() {
  return &id_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace das

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_das_2eproto__INCLUDED
